{"version":3,"sources":["../../../src/coooders/module/tool.js"],"names":["gcd","a","b","tcd","Spliter","strs","that","pri","buffer","isComplete","root","_","__","length","forEach","ds","Buffer","from","v","toJSON","data","start","v2","Error","end","now","push","pris"],"mappings":"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","file":"tool.js","sourcesContent":["import V from '../common/tool';\n/**\n * gcd 使用辗转相除法获取最大公约数 http://blog.jobbole.com/106315/\n */\nexport const gcd = function(a, b) {\n    if (a == b) return a;\n    else if (a < b) return gcd(b, a);\n    else {\n        if ((a & 1) == 0 && (b & 1) == 0) {\n            //偶数\n            return gcd(a >> 1, b >> 1) << 1;\n        } else if ((a & 1) == 0 && (b & 1) == 1) return gcd(a >> 1, b);\n        else if ((a & 1) == 1 && (b & 1) == 0) return gcd(a, b >> 1);\n        else return gcd(a - b, b);\n    }\n};\n/**\n * tcd 使用辗转相除法获取用最大公约数求最小公倍数\n */\nexport const tcd = function(a, b) {\n    return a / gcd(a, b) * b;\n};\nexport const Spliter = class {\n    constructor(strs = []) {\n        const that = this;\n        const { _, __ } = pri(that, { buffer: [], isComplete: false, root: {} });\n        if (strs && strs.length > 0) {\n            strs.forEach(v => {\n                var ds = new Buffer.from(v).toJSON().data;\n                var start = __.root;\n                ds.forEach(v2 => {\n                    if (start[v2]) {\n                        start[v2].length++;\n                    } else start[v2] = { length: 1 };\n                    start = start[v2];\n                });\n                if (start.length > 1) throw new Error('分隔符之间不能存在包含或者重复关系');\n                start.end = v;\n            });\n            __.now = __.root;\n        } else throw new Error('构造函数必须输入字符值');\n    }\n    next(data) {\n        const { _, __ } = pri(that);\n        if (__.now[data]) {\n            __.buffer.push(data);\n            if (__.now[data].end) {\n                __.isComplete = true;\n                __.buffer = __.now[data].end;\n            }\n            __.now = __.now[data];\n            return true;\n        } else return false;\n    }\n    get isComplete() { return __.isComplete; }\n    get rest() { return __.buffer; }\n    reset() {\n        const { _, __ } = pri(that);\n        __.buffer = [];\n        __.isComplete = false;\n        __.now = __.root;\n    }\n};\nexport default { gcd, tcd, Spliter };\nconst pri = V.pris();"]}