import V from '../common/tool';
import C from '../io/config';
import {
    Pool
} from '../collection/pool';
import M from 'mysql';
import M2 from 'mssql';
import Mem from 'memcached';
import Mon from 'mongodb';
import N from '../net/tool';
import Q from 'querystring';
import Mail from 'emailjs';
import es from 'elasticsearch';
import Redis from 'ioredis';
import S from 'soap';
const pri = V.pris();
//import nosql from './nosql';
/**
 * //依托Middler框架完成对数据类型文件的处理，包括mysql mongodb sqlserver memcache ObjectDB(即自定义function) WebSocket等等数据源类型的操作
	//实现对如下格式文件的处理
		Ni:{
			ajaxtest2:{command:'http://localhost/VESHTest/Module/help/test.tjsonp?_n=recorder',dbtype:'tjson',params:{limit:11},template:'template1'},
			ajaxtest1:{command:'http://localhost/KDAPI/Module/GetOrderTrackItems.tjsonp?_n=Order',dbtype:'tjson',params:{},template:'template1'},
			'ajaxtest1.Cache':{command:function(res,params){return res[params.cacheKey];不写即使用默认值},dbtype:'json',params:{},template:'template2'},
			'ajaxtest1.Set':{command:function(res,params){res[params.cacheKey] = params.cacheValue;不写即使用默认值},dbtype:'json',params:{timeout1:{interval:'s',number:50}},template:'template2'},
			sqlinsert:{command:'create table if not exists table(name Text,message text,time integer);insert into table values(?,?,?);',dbtype:'json',params:{data:[]},template:'sqltemp'},
			sqlselect:{command:'select * from table;',dbtype:'json',params:{data:[]},template:'sqltemp'},
			sqlselect2:{command:'select * from table where name=?',dbtype:'json',params:{data:[]},template:'sqltemp'},		
			Name1:{command:'',params:{},dbtype:'json/tjson',template:'仅在Middler中调用NiMultiTemplateDecorator时启用'},
			wstest1: { command: 'abc.json', dbtype: 'json', params: {}, template: 'ws' },
			wstest2: { command: 'bcd.json?_n=MT, dbtype: 'json', params: {}, template: 'ws' }
		}
let t = middler.getObjectByAppName('Ni','templatename');
let res = t.execute('aaa.GetProductDetail',{ProductID:111},function(result){
	let res = result.last();
});
middler.setObjectByAppName('Ni','templatename',t);
//分离NiDataConfig完成Ni格式文件处理
//分离NiDataConfigConvert完成对Ni格式转成Config
//用于处理 Ni文件定义
*/
export const NiDataConfig = class extends C.Config {
    constructor() {
        super();
        const that = this;
        const {
            _,
            __
        } = pri(that, {
            mergeValue: param => {
                switch (param.type) {
                    case 'Int':
                    case 'int':
                    case 'int32':
                    case 'int16':
                    case 'int64':
                        param.value = param.value ? parseInt(param.value) : 0;
                        break;
                    case 'DateTime':
                    case 'Date':
                    case 'datetime':
                        param.value = param.value ? (param.value.split ? Date.parse(param.value) : new Date(param.value)) : new Date(0);
                        break;
                    case 'float':
                    case 'single':
                    case 'double':
                        param.value = param.value ? parseFloat(param.value) : 0;
                        break;
                    case 'string':
                    case 'String':
                        param.value = param.value == null ? null : (param.value + '');
                        break;
                }
            }
        });
    }
    standard(val) {
        let ret = {};
        for (let k in val) {
            let v = val[k] || {
                value: val[k],
                isStandard: true
            };
            ret[k] = v.isStandard ? v : (v.type || (v.out && v.out != '')) ? (function() {
                v.isStandard = true;
                return v;
            })() : {
                value: v,
                isStandard: true
            };
        }
        return ret;
    }
    merge(...vals) {
        const {
            _,
            __
        } = pri(this);
        //默认设置最后一个参数为值，其它参数为标准化数据 key:{value:val,type:'',out:false,isStandard:true}
        vals.forEach((v, i) => vals[i] = _.standard(v));
        vals = V.merge.apply(null, vals);
        for (let k in vals)
            __.mergeValue(vals[k]);
        return vals;
    }
    getValue(...args) {
        const {
            _,
            __
        } = pri(this);
        const ret = super.getValue.apply(_, args); //这里借用VJ的方法将ni.js中定义的V.merge方法改为参数标准化方法
        if (ret) {
            ret.merge = ret.merge || function(...args2) {
                return _.merge.apply(_, args2);
            }
        }
        return ret;
    }
};
NiDataConfig.instance = new NiDataConfig();
export const NiDataConfigConvert = class extends C.ConfigConvert {
    constructor() {
        super();
        pri(this);
    }
    toConfig(val) {
        const ret = new NiDataConfig();
        if (val) {
            if (typeof(val) == 'object') {
                for (let k in val) {
                    let v = val[k];
                    if (v) ret.data[k.toLowerCase()] = V.merge({
                        params: {}
                    }, v);
                }
            }
        }
        return ret;
    }
}
export const NiTemplate = class {
    constructor(res, cm) {
        const that = this;
        this.transaction = false;
        const {
            _,
            __
        } = pri(that, {
            lstCmd: [],
            KEY: ('Ni'),
            result: new NiDataResult(),
            res,
            cm,
            addCommand: (name, params) => {
                const {
                    _,
                    __
                } = pri(that);
                const cmd = __.cm.getConfigValue(__.KEY, name.toLowerCase());
                let command = name;
                let template = "";
                if (cmd) {
                    command = cmd.command || name;
                    params = cmd.merge(cmd.params, V.getValue(params, {}));
                    template = cmd.template;
                } else params = NiDataConfig.instance.merge({}, params);
                __.lstCmd.push({
                    name: command,
                    params: params,
                    template: template,
                    key: name,
                    jsonp: (cmd && cmd.jsonp) ? cmd.jsonp : false,
                    dbtype: (cmd && cmd.dbtype) ? cmd.dbtype : "tjson"
                });
            },
            execute: async() => {
                const {
                    _,
                    __
                } = pri(that);
                let _cms = __.lstCmd;
                __.lstCmd = [];
                if (_cms.length > 0) {
                    let conn = await __.res.getDBConnection();
                    try {
                        if (_cms.length > 1) conn.transaction = true;
                        let cmd = __.res.getDBCommand();
                        cmd.connection = conn;
                        //执行过程存在严重漏洞 考虑 直接执行与非直接执行的异同
                        await V.each(_cms, async v => {
                            cmd.command = v.name;
                            cmd.params = v.params;
                            cmd.dbtype = v.dbtype;
                            cmd.jsonp = v.jsonp;
                            //需要知晓connection的执行原理
                            if (conn.transaction) {
                                cmd.execute();
                            } else {
                                const data = await cmd.execute();
                                __.result.add((!data || (V.isArray(data) && data.length == 0)) ? false : data, v.key);
                            }
                            return false;
                        }, true);
                        if (conn.transaction && conn.commit)
                            await conn.commit();
                        return true;
                    } catch (err) {
                        V.showException('commit ', err);
                        throw err;
                    } finally {
                        __.res.backDBConnection(conn);
                    }
                } else {
                    V.showException('不能调用空的命令对象!');
                }
            },
            excute: async() => await __.execute()
        });
    }
    async execute(name, params = {}) {
        const {
            _,
            __
        } = pri(this);
        //__.addCommand(name, V.json(V.toJsonString(params)));
        //__.addCommand(name, V.merge({},params));
        __.addCommand(name, params);
        if (!_.transaction) {
            __.result.clear();
            await __.execute();
        }
        return __.result;
    }
    async excute() {
        return await this.execute.apply(this, arguments);
    }
    async commit() {
        const {
            _,
            __
        } = pri(this);
        __.result.clear();
        await __.execute();
        return __.result;
    }
    dispose() {
        const {
            _,
            __
        } = pri();
        for (let i in __) {
            //if (__[i].dispose) try { __[i].dispose() } catch (e) {}
            delete __[i];
        }
    }
    getCommand(name = '') {
        const {
            __
        } = pri(this);
        return V.merge({}, __.cm.getConfigValue(__.KEY, name.toLowerCase()) || {});
    }
};
export const NiTemplateManager = class {
    constructor(middler, appName = 'Ni') {
        pri(this, {
            middler: middler,
            KEY: appName
        });
    }
    async execute(tempName, name, params, func) {
        const {
            _,
            __
        } = pri(this);
        let temp = __.middler.getObjectByAppName(__.KEY, tempName);
        if (temp) {
            let result = await temp.execute(name, params);
            __.middler.setObjectByAppName(__.KEY, tempName, temp);
            return result;
        } else {
            throw new Error('没有找到Template:' + tempName);
        }
    }
    async excute() {
        return await this.execute.apply(this, arguments);
    }
    dispose() {
        const {
            __
        } = pri(this);
        for (let i in __) delete __.i;
    }
    getCommand(tempName = '', name = '') {
        const {
            _,
            __
        } = pri(this);
        let temp = __.middler.getObjectByAppName(__.KEY, tempName);
        if (temp) {
            let result = temp.getCommand(name);
            __.middler.setObjectByAppName(__.KEY, tempName, temp);
            return result;
        } else {
            throw new Error('没有找到Template:' + tempName);
        }
    }
};

function hasData(data) {
    if (V.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            if (data[i] && hasData(data[i])) return true;
        }
    } else {
        for (let i in data)
            if (data[i] !== undefined) return true;
    }
    return false;
};
export const NiDataResult = class {
    constructor() {
        const {
            __
        } = pri(this, {
            data: {},
            kv: {},
            datas: [],
            hasData: hasData
        });
    }
    get(key) {
        const {
            _,
            __
        } = pri(this);
        return __.data[key] || (__.kv[key] ? __.kv[key][1] : null);
    }
    add(data, name) {
        const {
            _,
            __
        } = pri(this);
        if (data && !__.kv[name]) {
            __.data[__.datas.length] = data;
            __.kv[name] = [__.datas.length, data];
            __.datas.push(data);
        } else if (__.kv[name]) {
            const id = __.kv[name][0];
            __.data[id] = data;
            __.kv[name] = [__.datas.length, data];
            __.datas[id] = data;
        }
    }
    last() {
            const {
                _,
                __
            } = pri(this);
            return _.get(__.datas.length - 1);
        }
        /**
         * 一般用于处理单个对象
         */
    single() {
        const {
            _,
            __
        } = pri(this);
        return (_.hasData()) ? (function() {
            const data = _.get(__.datas.length - 1);
            return (data[0] && data[0][0]) ? data[0][0] : {};
        })() : null;
    }
    each(key, func) {
        const {
            _,
            __
        } = pri(this);
        let val = _.get(key);
        if (val && V.isArray(val)) {
            return V.each(val, func);
        } else throw new Error('遍历对象不存在或者不是数组')
    }
    clear() {
        const {
            _,
            __
        } = pri(this);
        __.data = {};
        __.kv = {};
        __.datas = [];
    }
    hasData(key) {
        const {
            _,
            __
        } = pri(this);
        return __.hasData(key ? get(key) : __.datas);
    }
};
/**
 * getDBConnection 异步
 */
export const NiDataResource = class {
    constructor(factory, params = {}) {
        const {
            _,
            __
        } = pri(this, {
            fac: factory,
            params: params
        });
    }
    async getDBConnection() {
        const {
            _,
            __
        } = pri(this);
        const conn = __.fac.createDBConnection();
        conn.setParams(__.params);
        //conn.params = V.merge(conn.params, __.params);
        if (!conn.isOpen) {
            //open需要转同步
            await conn.open();
        }
        return conn;
    }
    backDBConnection(conn) {
        const {
            _,
            __
        } = pri(this);
        __.fac.backDBConnection(conn);
    }
    getDBCommand() {
        const {
            _,
            __
        } = pri(this);
        return __.fac.createDBCommand();
    }
};
export const NiInstanceDataResource = class extends NiDataResource {
    constructor(factory, params = {}) {
        super(factory, params);
    }
    getDBConnection() {
        return super.getDBConnection();
    }
    backDBConnection(conn) {
        super.backDBConnection(conn);
    }
    getDBCommand() {
        return super.getDBCommand();
    }
};
export const NiStaticDataResource = class extends NiDataResource {
    constructor(factory, params = {}) {
        super(factory, params);
        pri(this, {
            conn: null
        });
    }
    async getDBConnection() {
        const {
            _,
            __
        } = pri(this);
        if (!__.conn || !__.conn.isOpen)
            __.conn = await super.getDBConnection();
        return __.conn;
    }
    backDBConnection(conn) {
        const {
            _,
            __
        } = pri(this);
        if (conn != __.conn && conn.isOpen)
            super.backDBConnection(conn);
    }
    getDBCommand() {
        return super.getDBCommand();
    }
};
export const NiPoolDataResource = class extends NiDataResource {
    constructor(factory, params = {}, size = 50) {
        super(factory, params);
        pri(this, {
            pool: new Pool(size, async() => {
                let conn = await super.getDBConnection();
                if (!conn.dispose)
                    conn.dispose = conn.close;
                return conn;
            })
        });
    }
    async getDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return await __.pool.getValue();
    }
    backDBConnection(conn) {
        const {
            _,
            __
        } = pri(this);
        __.pool.setValue(conn);
    }
};
export const NiDataFactory = class {
        constructor() {
            pri(this);
        }
        createDBConnection() {
            return new NiDataConnection();
        }
        createDBCommand() {
            return new NiDataCommand();
        }
        async backDBConnection(conn) {
            if (conn.isOpen) {
                await conn.close();
            }
        }
    }
    /**
     * Connection 全部是callback
     */
export const NiDataConnection = class {
    constructor() {
        pri(this);
        this.isOpen = false;
        this.transaction = false;
        this.params = {};
    }
    setParams(paras) {
        V.merge(this.params, paras, true);
    }
    async open() {
        const {
            _,
            __
        } = pri(this);
        _.isOpen = true;
    }
    async close() {
        const {
            _,
            __
        } = pri(this);
        _.isOpen = false;
    }
    async invoke(cmd) {
        return [];
    }
    async commit() {
        return [];
    }
};
/**
 * DBCommand 命令使用callback命令
 */
export const NiDataCommand = class {
    constructor() {
        const {
            _,
            __
        } = pri(this);
        _.connection = null;
        _.command = '';
        _.params = {
            dbtype: 'json'
        };
    }
    async execute() {
        const {
            _,
            __
        } = pri(this);
        if (!_.connection || !_.connection.isOpen) {
            V.showException('数据库未连接');
            throw new Error('数据库未连接');
        } else {
            try {
                //此句关键
                return await _.connection.invoke(_);
            } catch (e) {
                V.showException('connection invoke success方法', e);
                throw e;
            }
        }
    }
    async excute() {
        return await this.execute.apply(this, arguments);
    }
};

/**
 * 可以针对每个函数分别设置缓存方式和缓存字段
 * @param {*} res 
 * @param {*} cacheres 
 * @param {*} cm 
 * @param {*} params 
 */
export const NiTemplateDecorator = class extends NiTemplate {
    constructor(res, cacheres, cm, params = {}) {
        super(res, cm);
        const that = this;
        const {
            _,
            __
        } = pri(that, {
            KEY: 'Ni',
            lstCmd2: {},
            params,
            cacheres
        });
        const _addCommand = __.addCommand;
        const _execute = __.execute;
        __.addCommand = (name, params) => {
            const {
                _,
                __
            } = pri(that);
            let index = __.lstCmd.length;
            _addCommand.apply(_, [name, params]);
            if (__.lstCmd.length != index) {
                let command = null;
                let cmd = __.cm.getConfigValue(__.KEY, name.toLowerCase() + '.cache') || __.cm.getConfigValue(__.KEY, name.toLowerCase() + '.clear');
                if (cmd) {
                    command = cmd.command;
                    __.lstCmd2[index] = {
                        name: command,
                        key: name,
                        params: cmd.merge({
                            cacheKey: '' + V.hash(name + '.Set.' + V.toJsonString(__.lstCmd[__.lstCmd.length - 1].params))
                        }, cmd.params, __.lstCmd[__.lstCmd.length - 1].params)
                    }
                }
            }
        };
        __.execute = async() => {
            const {
                _,
                __
            } = pri(that);
            let _cms = __.lstCmd;
            __.lstCmd = [];
            if (_cms.length > 0) {
                let conn = await __.res.getDBConnection();
                try {
                    if (_cms.length > 1) conn.transaction = true;
                    let cmd = __.res.getDBCommand();
                    cmd.connection = conn;
                    //执行过程存在严重漏洞 考虑 直接执行与非直接执行的异同
                    let i = 0;
                    await V.each(_cms, async v => {
                        const _nicmd = __.lstCmd2[i++];
                        if (_nicmd) {
                            const _conn = await __.cacheres.getDBConnection();
                            try {
                                const _cmd = __.cacheres.getDBCommand();
                                _cmd.connection = _conn;
                                _cmd.command = _nicmd.name;
                                _cmd.params = V.merge(_nicmd.params, v.params);
                                _cmd.dbtype = v.dbtype;
                                _cmd.jsonp = v.jsonp;
                                let data = await _cmd.execute();
                                if (hasData(data)) {
                                    __.result.add((!data || (V.isArray(data) && data.length == 0)) ? false :
                                        V.json(data[0].cacheValue || (data[0][0] && data[0][0].cacheValue)), v.key);
                                    return false;
                                }
                            } finally {
                                __.cacheres.backDBConnection(_conn);
                            }
                        }
                        cmd.command = v.name;
                        cmd.params = v.params;
                        cmd.dbtype = v.dbtype;
                        cmd.jsonp = v.jsonp;
                        //需要知晓connection的执行原理
                        if (conn.transaction) {
                            cmd.execute();
                        } else {
                            let data = await cmd.execute();
                            __.result.add((!data || (V.isArray(data) && data.length == 0)) ? false : data, v.key);
                            if (data && data.length > 0 && !(data.length == 1 && data[0].length == 0)) {
                                //新增缓存
                                let _nicmd = __.cm.getConfigValue(__.KEY, v.key.toLowerCase() + '.set');
                                if (_nicmd) {
                                    const _conn = await __.cacheres.getDBConnection();
                                    try {
                                        const _cmd = __.cacheres.getDBCommand();
                                        _cmd.connection = _conn;
                                        _cmd.command = _nicmd.command;
                                        _cmd.params = _nicmd.merge({
                                            cacheKey: '' + V.hash(v.key + '.Set.' + V.toJsonString(cmd.params)),
                                            cacheValue: V.toJsonString(data)
                                        }, _nicmd.params, cmd.params);
                                        cmd.dbtype = v.dbtype;
                                        cmd.jsonp = v.jsonp;
                                        const _data = await _cmd.execute();
                                    } finally {
                                        __.cacheres.backDBConnection(_conn);
                                    }
                                }
                            }
                        }
                        return false;
                    }, true);
                    if (conn.transaction && conn.commit)
                        await conn.commit();
                    return __.result;
                } catch (err) {
                    V.showException('commit ', err);
                } finally {
                    __.res.backDBConnection(conn);
                }
            } else {
                V.showException('不能调用空的命令对象!');
            }
        };
        __.excute = async() => await __.execute();
    }
};

/**
 * 可以非常简单的设置缓存方式 但是存储命令只有cacheKey,cacheValue两种
 * @param {*} res 
 * @param {*} cacheres 
 * @param {*} cm 
 * @param {*} params 
 * @param {*} cachecommand //缓存命令
 * @param {*} setcommand //缓存设置命令
 */
export const NiTemplateCacheDecorator = class extends NiTemplate {
    constructor(res, cacheres, cm, params = {}, cachecommand = '', setcommand = '') {
        super(res, cm);
        const that = this;
        const {
            _,
            __
        } = pri(that, {
            KEY: 'Ni',
            lstCmd2: {},
            params,
            cacheres,
            cachecommand: cachecommand.toLowerCase(),
            setcommand: setcommand.toLowerCase()
        });
        const _addCommand = __.addCommand;
        const _execute = __.execute;
        __.addCommand = (name, params) => {
            const {
                _,
                __
            } = pri(that);
            let index = __.lstCmd.length;
            _addCommand.apply(_, [name, params]);
            if (__.lstCmd.length != index) {
                let command = null;
                let cmd = __.cm.getConfigValue(__.KEY, __.cachecommand);
                if (cmd) {
                    command = cmd.command;
                    __.lstCmd2[index] = {
                        name: command,
                        key: name,
                        params: cmd.merge({
                            cacheKey: '' + V.hash(name + '.Set.' + V.toJsonString(__.lstCmd[__.lstCmd.length - 1].params))
                        }, cmd.params, __.lstCmd[__.lstCmd.length - 1].params)
                    }
                }
            }
        };
        __.execute = async() => {
            const {
                _,
                __
            } = pri(that);
            let _cms = __.lstCmd;
            __.lstCmd = [];
            if (_cms.length > 0) {
                let conn = await __.res.getDBConnection();
                try {
                    if (_cms.length > 1) conn.transaction = true;
                    let cmd = __.res.getDBCommand();
                    cmd.connection = conn;
                    //执行过程存在严重漏洞 考虑 直接执行与非直接执行的异同
                    let i = 0;
                    await V.each(_cms, async v => {
                        const _nicmd = __.lstCmd2[i++];
                        if (_nicmd) {
                            const _conn = await __.cacheres.getDBConnection();
                            try {
                                const _cmd = __.cacheres.getDBCommand();
                                _cmd.connection = _conn;
                                _cmd.command = _nicmd.name;
                                _cmd.params = V.merge(_nicmd.params, v.params);
                                _cmd.dbtype = v.dbtype;
                                _cmd.jsonp = v.jsonp;
                                let data = await _cmd.execute();
                                if (hasData(data)) {
                                    __.result.add((!data || (V.isArray(data) && data.length == 0)) ? false :
                                        V.json(data[0].cacheValue || (data[0][0] && data[0][0].cacheValue)), v.key);
                                    return false;
                                }
                            } finally {
                                __.cacheres.backDBConnection(_conn);
                            }
                        }
                        cmd.command = v.name;
                        cmd.params = v.params;
                        cmd.dbtype = v.dbtype;
                        cmd.jsonp = v.jsonp;
                        //需要知晓connection的执行原理
                        if (conn.transaction) {
                            cmd.execute();
                        } else {
                            let data = await cmd.execute();
                            __.result.add((!data || (V.isArray(data) && data.length == 0)) ? false : data, v.key);
                            if (data && data.length > 0 && !(data.length == 1 && data[0].length == 0)) {
                                //新增缓存
                                let _nicmd = __.cm.getConfigValue(__.KEY, __.setcommand);
                                if (_nicmd) {
                                    const _conn = await __.cacheres.getDBConnection();
                                    try {
                                        const _cmd = __.cacheres.getDBCommand();
                                        _cmd.connection = _conn;
                                        _cmd.command = _nicmd.command;
                                        _cmd.params = _nicmd.merge({
                                            cacheKey: '' + V.hash(v.key + '.Set.' + V.toJsonString(cmd.params)),
                                            cacheValue: V.toJsonString(data)
                                        }, _nicmd.params, cmd.params);
                                        cmd.dbtype = v.dbtype;
                                        cmd.jsonp = v.jsonp;
                                        const _data = await _cmd.execute();
                                    } finally {
                                        __.cacheres.backDBConnection(_conn);
                                    }
                                }
                            }
                        }
                        return false;
                    }, true);
                    if (conn.transaction && conn.commit)
                        await conn.commit();
                    return __.result;
                } catch (err) {
                    V.showException('commit ', err);
                } finally {
                    __.res.backDBConnection(conn);
                }
            } else {
                V.showException('不能调用空的命令对象!');
            }
        };
        __.excute = async() => await __.execute();
    }
};

export const NiMultiTemplateDecorator = class extends NiTemplate {
    constructor(res, cm, relcm, appName = "Ni") {
        super(res, cm);
        const that = this;
        const {
            _,
            __
        } = pri(that, {
            KEY: appName,
            ni: new NiTemplateManager(relcm, appName),
            lstCmd2: {}
        });
        const _addCommand = __.addCommand;
        const _execute = __.execute; //todo 可能可以实现覆盖!
        __.addCommand = (name, params) => {
            const {
                _,
                __
            } = pri(that);
            let index = __.lstCmd.length;
            _addCommand.apply(_, [name, params]);
            let cmd = __.lstCmd[__.lstCmd.length - 1];
            if (cmd.template) {
                //调用templdate优先 复用其次
                __.lstCmd2[__.lstCmd.length - 1] = true;
            }
        };
        __.execute = async() => {
            const {
                _,
                __
            } = pri(that);
            let _cms = __.lstCmd,
                _cm2 = __.lstCmd2;
            __.lstCmd = [], __.lstCmd2 = {};
            if (_.transaction)
                throw new Error('NiMultiTemplateDecorator不支持事务，容易发生内容错位');
            if (_cms.length > 0) {
                let i = 0;
                await V.each(_cms, async v => {
                    let _nicmd = _cm2[i++];
                    if (_nicmd) {
                        const result = await __.ni.execute(v.template, v.key, v.params);
                        __.result.add((result && result.get(v.key)) ? result.get(v.key) : [], v.key);
                    } else {
                        const conn = await __.res.getDBConnection();
                        try {
                            let cmd = __.res.getDBCommand();
                            cmd.connection = conn;
                            cmd.command = v.name;
                            cmd.params = v.params;
                            cmd.dbtype = v.dbtype;
                            cmd.jsonp = v.jsonp;
                            const data = await cmd.execute();
                            __.result.add((typeof(data) == 'undefined' || (V.isArray(data) && data.length == 0)) ? false : data, v.key);
                        } finally {
                            __.res.backDBConnection(conn);
                        }
                    }
                    return false;
                }, true);
            } else {
                V.showException('不能调用空的命令对象!');
            }
            return __.result;
        };
        __.excute = async() => await __.execute();
    }
    dispose() {
        const {
            __
        } = pri(this);
        __.ni.dispose();
        super.dispose();
    }
};
/**
 * MySQL 池连接方式工厂
 */
export const NiMySQLDataFactory = class extends NiDataFactory {
    constructor() {
        super();
        const that = this;
        that.idic = {};
        const {
            _,
            __
        } = pri(that, {
            MySQLConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const that = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        conn: null,
                        getValue: p => p.value,
                        toList: vals => {
                            const {
                                _,
                                __
                            } = pri(that);
                            if (vals[0]) {
                                let ret = [];
                                for (let i = 0; i < vals.length; i++)
                                    ret.push(__.toList(vals[i]));
                                return ret;
                            } else return (function() {
                                const ret = {};
                                for (let k in vals) {
                                    switch (V.getType(vals[k])) {
                                        case 'Date':
                                        case 'number':
                                        case 'boolean':
                                        case 'string':
                                        case 'null':
                                            ret[k] = vals[k];
                                            break;
                                    }
                                }
                                return ret;
                            })();
                        },
                        invoke: async(command, params) => {
                            try {
                                const {
                                    _,
                                    __
                                } = pri(that);

                                let result = await V.callback(__.conn.query, __.conn, _.prepare(command, params));

                                let data = [];
                                if (!result[0]) result = [
                                    []
                                ];
                                //过滤mysql自定义的更新结果JSON
                                result = result.filter(v => v.serverStatus == undefined);

                                //过滤mysql上复制:=
                                result = result.filter(v => {
                                    switch (V.getType(v)) {
                                        case 'object':
                                        case 'Object':
                                            for (var k in v) {
                                                if (k.indexOf(':=') >= 0) return false;
                                            }
                                            break;
                                        case 'Array':
                                            const _v = v.filter(r => {
                                                for (var k2 in r) {
                                                    if (k2.indexOf(':=') >= 0) return false;
                                                }
                                                return true;
                                            });
                                            return _v.length > 0 || v.length == 0;
                                    }
                                    return true;
                                });
                                if (!result[0]) result = [
                                    []
                                ];
                                if (V.getType(result[0]).toLowerCase() != 'array') result = [result];
                                //自动补充mysql在单sql下不是2个嵌套数据的问题
                                if (result && result.length > 0)
                                    for (let i = 0; i < result.length; i++) {
                                        if (typeof(result[i]) != 'undefined' && result[i].length > 0)
                                            data.push(__.toList(result[i]));
                                        else if (typeof(result[i]) != 'undefined' && !V.isArray(result[i])) { //if (typeof(result[i].affectedRows) == 'undefined') {
                                            data.push(__.toList([result[i]]));
                                        } else {
                                            data.push([]);
                                        }
                                    }
                                else data.push([]);
                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                    _.params = {
                        multipleStatements: true,
                        connectionLimit: 10
                    };
                }
                prepare(cmd, paras) {
                    const {
                        _,
                        __
                    } = pri(this);
                    //需要将{}转成[] 处理
                    if (cmd && paras) {
                        let vals = [];
                        cmd = cmd.replace(/\?[a-zA-Z0-9_]+/g, (data) => {
                            try {
                                vals.push(__.getValue(paras[data.trim('?')]));
                                return '?';
                            } catch (e) {
                                throw data.trim('?') + '未找到参数定义'
                            }
                        });
                        return {
                            sql: cmd,
                            values: vals,
                            timeout: _.params.timeout || 60000 //1分钟
                        };
                    } else
                        throw new Error('prepare方法要求写入command参数与paras参数');
                }
                async invoke(cmd) {
                    //需要处理单条与多条s
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else {
                        /*if (cmd.command.split(';').filter(e => e.length) > 1) {
                            //事务性处理
                            __.cmds.push({
                                command: cmd.command,
                                params: cmd.params
                            });
                            return await _.commit()[0];
                        } else*/
                        return await __.invoke(cmd.command, cmd.params);
                    }
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        try {
                            await V.callback(__.conn.beginTransaction, __.conn);
                            let data = [];
                            let cmds = __.cmds;
                            __.cmds = [];
                            await V.each(cmds, async v => {
                                //console.log(v.cmd.params);
                                data.push(await __.invoke(v.command, v.params));
                                return false;
                            }, true);
                            await V.callback(__.conn.commit, __.conn);
                            return data;
                        } catch (e) {
                            await V.callback(__.conn.rollback, __.conn);
                            throw e;
                        }
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);
                    const key = V.hash2(V.toJsonString(_.params));
                    that.idic[key] = that.idic[key] || M.createPool(_.params);

                    var getonconn = async function() {
                        var conn = await V.callback(that.idic[key].getConnection, that.idic[key]);
                        conn._key = key;
                        if (!!!conn._ison) {
                            conn._ison = true
                            conn.on('error', async function(err) {
                                if (err.code == 'PROTOCOL_CONNECTION_LOST' ||
                                    err.code == 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR') {
                                    try {
                                        //conn.close();
                                        that.idic[key] && that.idic[key].releaseConnection(conn)
                                    } catch (e) {}
                                    __.conn = await getonconn();
                                }
                            })
                        }

                        return conn;
                    };
                    __.conn = await getonconn();

                    await super.open();
                }
                async close() {
                    const {
                        _,
                        __
                    } = pri(this);
                    try {
                        if (__.conn && __.conn._key && that.idic[__.conn._key])
                            that.idic[__.conn._key].releaseConnection(__.conn);
                        else if (__.conn && __.conn.end)
                            __.conn.end();
                        else if (__.conn && __.conn.dispose)
                            __.conn.dispose();
                    } catch (e) {}
                    __.cmds = [];
                    __.conn = null;
                    await super.close();
                }
            }
        });
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.MySQLConnection();
    }
    dispose() {
        for (let i in this.idic) {
            if (this.idic[i] && this.idic[i].dispose) {
                const v = this.idic[i];
                V.tryC(() => {
                    v.dispose();
                })
            }
        }
    }
};

/*
默认类型转换
String -> sql.NVarChar
Number -> sql.Int
Boolean -> sql.Bit
Date -> sql.DateTime
Buffer -> sql.VarBinary
sql.Table -> sql.TVP
特别定义 param length 和 scale属性 分别对应 长度和精度（仅限Decimal和Numberic）
 */
export const NiMsSQLDataFactory = class extends NiDataFactory {
    constructor() {
        super();
        const that = this;
        that.idic = {};
        const {
            _,
            __
        } = pri(that, {
            MsSQLConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const that = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        conn: null,
                        invoke: async(source, command, params) => {
                            try {
                                const {
                                    _,
                                    __
                                } = pri(that);
                                const request = new M2.Request(source);
                                request.multiple = true;
                                for (let i in params) {
                                    //ni params 应该有 name:{type:'',value:''} or name:string ni定义未必支持
                                    const type = M2[V.getValue(params[i].type, 'NVarChar')] || M2.NVarChar;
                                    if (params[i].out)
                                        request.output(i, (params[i].length || 0) > 0 ? type(params[i].length) : type, params[i].value);
                                    else
                                        switch ((params[i].type + '').toLowerCase()) {
                                            case 'decimal':
                                            case 'numeric':
                                                request.input(i, type(params[i].length || 10, params[i].scale || 2), params[i].value);
                                                break;
                                            default:
                                                request.input(i, (params[i].length || 0) > 0 ? type(params[i].length) : type, params[i].value);
                                                break;
                                        }

                                }
                                let [result, affected] = [null, 0];
                                //await V.callback(request.prepare, request, command);
                                [result, affected] = await V.callback(call => {
                                    if (command.indexOf(' ') >= 0)
                                        request.query(command, (err, result) => call(err, [result, err ? 0 : result.rowsAffected]));
                                    else
                                        request.execute(command, (err, result) => call(err, [result, err ? 0 : result.rowsAffected]));
                                });

                                //await V.callback(request.unprepare, request);
                                let data = [];
                                //特别注意单行的处理，可能会导致单行无数据
                                if (result.recordsets && result.recordsets.length > 0)
                                    for (let i = 0; i < result.recordsets.length; i++) {
                                        if (result.recordsets[i] && result.recordsets[i].length > 0)
                                            data.push(result.recordsets[i]);
                                        else data.push((affected[i]) ? [{
                                            affected: affected[i]
                                        }] : []);
                                    }
                                else data.push((affected && affected[0]) ? [{
                                    affected: affected[0]
                                }] : []);
                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                    _.params = {
                        connectionLimit: 10,
                        timeout: 60000
                    };
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else {
                        /*if (cmd.command.split(';').filter(e => e.length) > 1) {
                            //事务性处理
                            __.cmds.push({
                                command: cmd.command,
                                params: cmd.params
                            };
                            return await _.commit()[0];
                        } else*/
                        return await __.invoke(__.conn, cmd.command, cmd.params);
                    }
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let trans = new M2.Transaction(__.conn);
                        try {
                            await V.callback(trans.begin, trans);
                            let data = [];
                            let cmds = __.cmds;
                            __.cmds = [];
                            await V.each(cmds, async v => {
                                data.push(await __.invoke(trans, v.command, v.params));
                                return false;
                            }, true);
                            await V.callback(trans.commit, trans);
                            return data;
                        } catch (e) {
                            await V.callback(trans.rollback, trans);
                            throw e;
                        }
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);
                    const key = V.hash2(V.toJsonString(_.params));
                    const func = function() {
                        const conn = new M2.ConnectionPool(_.params);
                        conn.on('error', function(err) {
                            console.log('GCL mssql error:' + err.stack);
                            __.conn = func();
                        });
                        return conn;
                    }
                    __.conn = func();
                    await V.callback(__.conn.connect, __.conn);
                    await super.open();
                }
                async close() {
                    const {
                        _,
                        __
                    } = pri(this);
                    try {
                        if (__.conn && __.conn.close)
                            __.conn.close();
                        else if (__.conn && __.conn.end)
                            __.conn.end();
                        else if (__.conn && __.conn.dispose)
                            __.conn.dispose();
                    } catch (e) {} finally {
                        //const key = V.hash2(V.toJsonString(_.params));
                        //delete that.idic[key];
                    }
                    __.cmds = [];
                    __.conn = null;
                    await super.close();
                }
            }
        });
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.MsSQLConnection();
    }
    dispose() {
        for (let i in this.idic) {
            if (this.idic[i] && this.idic[i].close) {
                const v = this.idic[i];
                V.tryC(() => {
                    v.close();
                })
                delete this.idic[i];
            }
        }
    }
};

/**
 * 分离NiDBFactory产生NiDBConnection(Invoke) mysql,sqlserver,memcache,mongo websocket ObjectDB等各种资源
 */
export const NiObjectDataFactory = class extends NiDataFactory {
    constructor(middler = null) {
        super();
        if (!V.isValid(middler)) throw new Error('参数的定义必须要输入middler参数');
        const that = this;
        const {
            _,
            __
        } = pri(that, {
            middler: middler,
            ObjectConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        invoke: async(command, params) => {
                            try {
                                command = command.trim();
                                if (typeof(__.obj[command]) == 'function') {
                                    let paras = [];
                                    for (let k in params) {
                                        let v = params[k];
                                        paras.push(v.value);
                                    };
                                    return await V.callback2(__.obj[command], __.obj, ...paras) || true;
                                } else throw new Error(command + '方法没有在对象源上找到');
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                    _.params = {
                        app: 'Ni',
                        name: ''
                    };
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (V.isValid(_.params.name)) {
                        //证明可用
                        __.obj = middler.getObjectByAppName(_.params.app, _.params.name);
                        if (!__.obj) throw new Error(`N.NiObjectDataFactory 无法创建<${_.params.app}/${_.params.name}>对象`);
                    } else throw new Error(`N.NiObjectDataFactory 无法找到<'${_.params.app}/${_.params.name}>对象`);
                    await super.open();
                }
                async close() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (__.obj) {
                        middler.setObjectByAppName(_.params.app, _.params.name, __.obj);
                        delete __.obj;
                    }
                    await super.close();
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let data = [];
                        let cmds = __.cmds;
                        __.cmds = [];
                        await V.each(cmds, async v => {
                            data.push(await __.invoke(v.command, v.params));
                            return false;
                        }, true);
                        return data;
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
            }
        });
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.ObjectConnection();
    }
};

/**
 * MemCached
 * @param {*} parser 
 */
export const NiMemSQLDataFactory = class extends NiDataFactory {
    constructor(parser) {
        super();
        let that = this;
        const {
            _,
            __
        } = pri(that, {
            MemSQLConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const _this = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        conn: null,
                        invoke: async(command, params) => {
                            try {
                                const {
                                    _,
                                    __
                                } = pri(_this);
                                let queryList = that.parser.parse(command, params);
                                let data = [];
                                await V.each(queryList, async(v, call) => {
                                    let cacheKey = _this.getKey(v);
                                    switch (v.Method.toLowerCase().trim()) {
                                        case "select":
                                            {
                                                data.push([await V.callback(call => __.conn.get(cacheKey, call))]);
                                            }
                                            break;
                                        case "insert":
                                        case "update":
                                            {
                                                const datetime = V.getValue(V.toJsonString(v.DateTimeParam).length > 2 ? (() => {
                                                    for (let k in v.DateTimeParam) return v.DateTimeParam[k];
                                                })() : _.params.datetime);
                                                const values = {};
                                                for (let k in v.MethodParam) {
                                                    let v2 = v.MethodParam[k];
                                                    v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                    values[k] = v2;
                                                    if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                }
                                                await V.callback(__.conn.set, __.conn, cacheKey, values, datetime);
                                                data.push([{
                                                    value: 1
                                                }]);
                                            }
                                            break;
                                        case "delete":
                                            {

                                                await V.callback(__.conn.del, __.conn, cacheKey);
                                                data.push([{
                                                    value: 1
                                                }]);
                                            }
                                            break;
                                        case "touch":
                                            {

                                                let dt = V.toJsonString(v.DateTimeParam).length > 2 ? (() => {
                                                    for (let k in v.DateTimeParam) return v.DateTimeParam[k];
                                                })() : _.params.datetime;
                                                await V.callback(__.conn.touch, __.conn, cacheKey, dt);
                                                data.push([{
                                                    value: 1
                                                }]);
                                            }
                                            break;
                                    }
                                    return false;
                                }, true);
                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                    _.params = {
                        connectionLimit: 10,
                        datetime: 1000
                    };
                }
                getKey(p) {
                    let cacheKey = p.Table;
                    if (V.toJsonString(p.IDs).length > 2) {
                        let sb = V.sb();
                        for (let k in p.IDs)
                            sb.append(p.IDs[k]).append('_');
                        cacheKey += ("K" + V.hash(sb.clear().trim('_')));
                        sb = null;
                    } else if (p.Params["cacheKey"])
                        cacheKey += ("K" + V.hash(p.Params["cacheKey"][0], true));
                    else
                        throw new Error("表未定义<主键>,或者传入键值中未找到cacheKey");
                    return cacheKey;
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let data = [];
                        let cmds = __.cmds;
                        __.cmds = [];
                        await V.each(cmds, async v => {
                            data.push(await __.invoke(v.command, v.params));
                            return false;
                        }, true);
                        return data;
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
                async open() {
                    //https://www.npmjs.com/package/memcached#options
                    const {
                        _,
                        __
                    } = pri(this);
                    __.conn = new Mem(_.params.hosts, _.params);
                    await super.open();
                }
                async close() {
                    const {
                        _,
                        __
                    } = pri(this);
                    try {
                        __.conn.end();
                    } catch (e) {}
                    __.cmds = [];
                    __.conn = null;
                    await super.close();
                }
            }
        });
        _.parser = parser;
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.MemSQLConnection();
    };
    backDBConnection(conn) {
        conn.close();
    };
};

/**
 * https://www.npmjs.com/package/memcached#options
 */
export const NiMongoSQLDataFactory = class extends NiDataFactory {
    constructor(parser) {
        super();
        let that = this;
        const {
            _,
            __
        } = pri(that, {
            MongoSQLConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    let _this = this;
                    const {
                        _,
                        __
                    } = pri(_this, {
                        cmds: [],
                        conn: null,
                        invoke: async(command, params) => {
                            try {
                                const {
                                    _,
                                    __
                                } = pri(_this);
                                let queryList = _this.parse(command, params);
                                let data = [];
                                await V.each(queryList, async(v) => {
                                    const func = (data, p) => {
                                        for (let k in data) {
                                            let v = data[k];
                                            if (typeof(v.value) != 'undefined' || typeof(v._id) != 'undefined') {
                                                p[k] = v.value;
                                            } else {
                                                p[k] = {};
                                                func(v, p.k);
                                            }
                                        }
                                    };
                                    let wheres = {};
                                    func(v.WhereParam, wheres);

                                    const values = {};
                                    for (let k in v.MethodParam) {
                                        let v2 = v.MethodParam[k];
                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                        values[k] = v2;
                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                    }
                                    switch (v.Method.toLowerCase().trim()) {
                                        case "select":
                                            data.push(await V.callback(call => __.conn.collection(v.Table).find(wheres).toArray(call)));
                                            break;
                                        case "insert":
                                            //应该是更新
                                            await V.callback(call => __.conn.collection(v.Table).insert(values, {
                                                safe: true
                                            }, call));
                                            data.push({
                                                value: 1
                                            });
                                            break;
                                        case "update":
                                            await V.callback(call => __.conn.collection(v.Table).update(wheres, {
                                                '$set': values
                                            }, {
                                                safe: true
                                            }, call));
                                            data.push({
                                                value: 1
                                            });
                                            break;
                                        case "delete":
                                            await V.callback(call => __.conn.collection(v.Table).remove(wheres, {
                                                safe: true
                                            }, call));
                                            data.push({
                                                value: 1
                                            });
                                            break;
                                    }
                                    return false;
                                }, true);
                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                    _.params = {
                        connectionLimit: 10
                    };
                }
                parse(sql, params) {
                    const {
                        _,
                        __
                    } = this;
                    const ret = that.parser.parse(sql, params);
                    const param = {};
                    const func = (data, p) => {
                        for (let k in data) {
                            let v = data[k];
                            if (v.split) {} else {
                                p[k] = {};
                                func(v, p.k)
                            };
                            switch (k.toLowerCase()) {
                                case 'or':
                                    const _data = [];
                                    p['$or'] = _data;
                                    for (let k2 in p[k]) {
                                        let v2 = p[k][k2];
                                        _data.push({
                                            k2: v2
                                        });
                                    }
                                    break;
                                case 'and':
                                    p = V.merge(p, v);
                                    break;
                                case 'in':
                                    //todo
                                    break;
                                case '<':
                                    for (let k2 in p[k]) {
                                        let v2 = p[k][k2];
                                        if (p[k2]) {
                                            if (p[k2].split) {} else p[k2]['$lt'] = v2;
                                        } else p[k2] = {
                                            "$lt": v2
                                        }
                                    }
                                    break;
                                case '<=':
                                    for (let k2 in p[k]) {
                                        let v2 = p[k][k2];
                                        if (p[k2]) {
                                            if (p[k2].split) {} else p[k2]['$lte'] = v2;
                                        } else p[k2] = {
                                            "$lte": v2
                                        }
                                    }
                                    break;
                                case '>':
                                    for (let k2 in p[k]) {
                                        let v2 = p[k][k2];
                                        if (p[k2]) {
                                            if (p[k2].split) {} else p[k2]['$gt'] = v2;
                                        } else p[k2] = {
                                            "$gt": v2
                                        }
                                    }
                                    break;
                                case '>=':
                                    for (let k2 in p[k]) {
                                        let v2 = p[k][k2];
                                        if (p[k2]) {
                                            if (p[k2].split) {} else p[k2]['$gte'] = v2;
                                        } else p[k2] = {
                                            "$gte": v2
                                        }
                                    }
                                    break;
                            }
                        }
                    };
                    func(ret.WhereParam, param);
                    return ret;
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: com.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let data = [];
                        let cmds = __.cmds;
                        __.cmds = [];
                        await V.each(cmds, async v => {
                            data.push(await __.invoke(v.command, v.params));
                            return false;
                        }, true);
                        return data;
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);
                    __.conn = await V.callback(Mon.MongoClient.connect, Mon.MongoClient, _.params.hosts);
                    await super.open();
                }
                async close() {
                    const {
                        _,
                        __
                    } = pri(this);
                    try {
                        __.conn.close();
                    } catch (e) {}
                    __.conn = null;
                    __.cmds = [];
                    await super.close();
                }
            }
        });
        _.parser = parser;
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.MongoSQLConnection();
    };
    backDBConnection(conn) {
        conn.close();
    };
};

/*redis nosql 支持
 * 目前事务未支持
 */
export const NiRedisSqlDataFactory2 = class extends NiDataFactory {
    constructor(parser) {
        super();
        let that = this;
        const {
            _,
            __
        } = pri(that, {
            RedisSqlConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const _this = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        host: "",
                        port: "",
                        password: "",
                        method: "",
                        timeout: 60000,
                        db: 0,
                        conn: null,
                        getValues: function(data, keys) {
                            var ret = {},
                                i = 0;
                            for (let k in keys)(ret[k] = data[k], i++);
                            return i ? ret : data;
                        },
                        invoke: async(command, params) => {
                            const {
                                _,
                                __
                            } = pri(_this);
                            try {
                                let queryList = that.parser.parse(command, params);
                                let data = [];
                                var trans = false;
                                var transprefunc = [];
                                var transfunc = [];
                                var debug = (params['_debug'] && params['_debug'].value);
                                await V.each(queryList, async(v, call) => {
                                        var table = V.hash2(v.Table) + "";
                                        var key1 = V.toJsonString(v.IDs);
                                        var key = V.hash2(key1) + "";
                                        switch (v.Method.toLowerCase().trim()) {
                                            case "transaction":
                                                trans = true;
                                                break;
                                            case "select":
                                                {
                                                    key = v.Table + key;
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', key);
                                                    if (trans) {
                                                        transfunc.push(call => __.conn.get(key, call));
                                                    } else {
                                                        const res = await V.callback(call => __.conn.get(key, call));
                                                        try {
                                                            const jsdat = ('' + res).startsWith('{') ? __.getValues(V.json(res), v.MethodParam) : res;

                                                            data.push([jsdat]);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case 'increase':
                                                {
                                                    const datetime2 = V.toJsonString(v.DateTimeParam).length > 2 ? (() => {
                                                        for (let k in v.DateTimeParam) return v.DateTimeParam[k];
                                                    })() : _.params.datetime;
                                                    const values2 = {};
                                                    for (let k in v.MethodParam) {
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values2[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }

                                                    const key2 = V.hash2(V.toJsonString(v.IDs)) + "";
                                                    const value2 = (values2['_value'] !== undefined && values2['_value'] !== null) ? values2['_value'] : V.toJsonString(values2);
                                                    const majorkey2 = v.Table + key2;
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', majorkey2);
                                                    let func = null;
                                                    if (datetime2 != '-1') {
                                                        func = call => {
                                                            __.conn.incrby(majorkey2, value2, (err, ret) => {
                                                                if (err) call(err);
                                                                else
                                                                    __.conn.expire(majorkey2, (parseInt(datetime2) || 0) / 1000, function(err) {
                                                                        call(err, ret);
                                                                    });
                                                            });
                                                        }
                                                    } else {
                                                        func = call => { __.conn.incrby(majorkey2, value2, call); }
                                                    }

                                                    if (trans) {
                                                        //transprefunc.push(call => __.conn.watch(majorkey2, call)
                                                        transfunc.push(func);
                                                    } else {
                                                        const res = await V.callback(func);
                                                        data.push([{
                                                            value: res
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case 'lock':
                                                {
                                                    const datetime = V.toJsonString(v.DateTimeParam).length > 2 ? (() => {
                                                        for (let k in v.DateTimeParam) return v.DateTimeParam[k];
                                                    })() : _.params.datetime;
                                                    const values = {};
                                                    for (let k in v.MethodParam) {
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }

                                                    const value = (values['_value'] !== undefined && values['_value'] !== null) ? values['_value'] : V.toJsonString(values);
                                                    const majorkey = v.Table + key;
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', majorkey);
                                                    let func = null;
                                                    //setnx 设置安全锁
                                                    if (datetime != '-1') {
                                                        func = call => {
                                                            __.conn.setnx(majorkey, value, (err, ret) => {
                                                                if (err) call(err);
                                                                else
                                                                    __.conn.expire(majorkey, (parseInt(datetime) || 0) / 1000, function(err) {
                                                                        call(err, ret);
                                                                    });
                                                            });
                                                        }
                                                    } else {
                                                        func = call => __.conn.setnx(majorkey, value, call);
                                                    }
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(majorkey, call));
                                                        transfunc.push(func);
                                                    } else {
                                                        var ret = await V.callback(func);
                                                        data.push([{
                                                            value: ret
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "insert":
                                            case "update":
                                                {
                                                    const datetime = V.toJsonString(v.DateTimeParam).length > 2 ? (() => {
                                                        for (let k in v.DateTimeParam) return v.DateTimeParam[k];
                                                    })() : _.params.datetime;
                                                    const values = {};
                                                    for (let k in v.MethodParam) {
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }

                                                    const value = (values['_value'] !== undefined && values['_value'] !== null) ? values['_value'] : V.toJsonString(values);
                                                    const majorkey = v.Table + key;
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', majorkey);
                                                    let func = null;
                                                    //setnx 设置安全锁
                                                    if (datetime != '-1') {
                                                        func = call => __.conn.set(majorkey, value, "px", datetime, call);
                                                    } else {
                                                        func = call => __.conn.set(majorkey, value, call);
                                                    }

                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(majorkey, call));
                                                        transfunc.push(func);
                                                    } else {
                                                        await V.callback(func);
                                                        data.push([{
                                                            value: 1
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "delete":
                                                {
                                                    var majorkey = v.Table + key;
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', majorkey);
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(majorkey, call));
                                                        transfunc.push(call => {
                                                            __.conn.del(majorkey, () => {
                                                                __.conn.del(table, call);
                                                            })
                                                        });
                                                    } else {
                                                        await V.callback(call => __.conn.del(majorkey, call));
                                                        await V.callback(call => __.conn.del(table, call));
                                                        data.push([{
                                                            value: 1
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case 'hkeys':
                                                {
                                                    if (trans) {
                                                        debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                        transfunc.push(call => __.conn.hgetall(table, (e, d) => {
                                                            if (e) call(e)
                                                            else {
                                                                var ID = (function() {
                                                                    for (var k in v.IDs) return k;
                                                                })() || '';
                                                                var keys = {};
                                                                for (var k in d || {}) {
                                                                    try {
                                                                        if (k.startsWith('{')) k = V.json(k)[ID];
                                                                    } catch (e) {
                                                                        console.log('hgets json error', v2);
                                                                    }
                                                                    keys[k] = true;
                                                                }
                                                                call(null, keys)
                                                            }
                                                        }));
                                                    } else {
                                                        debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                        let res = await V.callback(call => __.conn.hgetall(table, (e, d) => {

                                                            var ID = (function() {
                                                                for (var k in v.IDs) return k;
                                                            })() || '';
                                                            var keys = {};
                                                            for (var k in d || {}) {
                                                                try {
                                                                    if (k.startsWith('{')) k = V.json(k)[ID];
                                                                } catch (e) {
                                                                    console.log('hgets json error', v2);
                                                                }
                                                                keys[k] = true;
                                                            }
                                                            call(null, keys)
                                                        }));
                                                        try {
                                                            data.push([res]);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case 'hgets':
                                                {
                                                    if (trans) {
                                                        debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                        transfunc.push(call => __.conn.hgetall(table, (e, d) => {
                                                            if (e) call(e)
                                                            else {
                                                                var ID = (function() {
                                                                    for (var k in v.IDs) return k;
                                                                })() || '';
                                                                var keys = {};
                                                                for (var k in d || {}) {
                                                                    var v2 = d[k];
                                                                    try {
                                                                        if (k.startsWith('{')) k = V.json(k)[ID];
                                                                        if (v2.startsWith('{')) v2 = V.json(V.json(v2).value);
                                                                    } catch (e) {
                                                                        console.log('hgets json error', v2);
                                                                    }
                                                                    keys[k] = v2;
                                                                }
                                                                call(null, keys)
                                                            }
                                                        }));
                                                    } else {
                                                        debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                        let res = await V.callback(call => __.conn.hgetall(table, (e, d) => {

                                                            var ID = (function() {
                                                                for (var k in v.IDs) return k;
                                                            })() || '';
                                                            var keys = {};
                                                            for (var k in d || {}) {
                                                                var v2 = d[k];
                                                                try {
                                                                    if (k.startsWith('{')) k = V.json(k)[ID];
                                                                    if (v2.startsWith('{')) v2 = V.json(V.json(v2).value);
                                                                } catch (e) {
                                                                    console.log('hgets json error', v2);
                                                                }
                                                                keys[k] = v2;
                                                            }
                                                            call(null, keys)
                                                        }));
                                                        try {
                                                            data.push([res]);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case "hlen":
                                            case "hcount":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    if (trans) {
                                                        transfunc.push(call =>
                                                            __.conn.hlen(table, call));
                                                    } else {
                                                        try {
                                                            let res = await V.callback(call => __.conn.hlen(table, call));
                                                            data.push([{ count: res }]);
                                                        } catch (e) {
                                                            data.push([{ count: 0 }]);
                                                        }
                                                    }
                                                }
                                                break;
                                            case "hselect":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    if (trans) {
                                                        transfunc.push(call => __.conn.hget(table, key1, call));
                                                    } else {
                                                        const res = await V.callback(call => __.conn.hget(table, key1, call));
                                                        try {
                                                            const jsdat = ('' + res).startsWith('{') ? __.getValues(V.json(res), v.MethodParam) : res;
                                                            data.push([jsdat]);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case "hmselect":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    var keys = v.IDs[Object['keys'](v.IDs)[0]].split(',');
                                                    if (trans) {
                                                        transfunc.push(call => __.conn.hmget(table, keys, call));
                                                    } else {
                                                        const res = await V.callback(call => __.conn.hmget(table, keys, call));
                                                        try {
                                                            const jsdat = [];
                                                            res.forEach(v2 => jsdat.push(('' + v).startsWith('{') ? __.getValues(V.json(v2), v.MethodParam) : v2));
                                                            data.push(jsdat);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case 'hlock':
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    const values3 = {};
                                                    for (let k in v.MethodParam) {
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values3[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }
                                                    const value3 = (values3['_value'] !== undefined && values3['_value'] !== null) ? values3['_value'] : V.toJsonString(values3);
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call))
                                                        transfunc.push(call => __.conn.hsetnx(table, key1, value3, call));
                                                    } else {
                                                        var ret = await V.callback(call => __.conn.hsetnx(table, key1, value3, call));
                                                        data.push([{
                                                            value: ret
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "hinsert":
                                            case "hupdate":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    const values3 = {};
                                                    for (let k in v.MethodParam) {
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values3[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }
                                                    const value3 = (values3['_value'] !== undefined && values3['_value'] !== null) ? values3['_value'] : V.toJsonString(values3);
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call))
                                                        transfunc.push(call => __.conn.hmset(table, key1, value3, call));
                                                    } else {
                                                        await V.callback(call => __.conn.hmset(table, key1, value3, call));
                                                        data.push([{
                                                            value: 1
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "hincrease":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    let values3 = {};
                                                    for (let k in v.MethodParam) {
                                                        if (!k) { continue; }
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values3[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }
                                                    let value3 = (values3['_value'] !== undefined && values3['_value'] !== null) ? values3['_value'] : V.toJsonString(values3);
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call))
                                                        transfunc.push(call => __.conn.hincrby(table, key1, value3, call));
                                                    } else {
                                                        var ret = await V.callback(call => __.conn.hincrby(table, key1, value3, call));
                                                        data.push([{
                                                            value: ret
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "hdelete":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table));
                                                        transfunc.push(call => __.conn.hdel(table, key1, call));
                                                    } else {
                                                        await V.callback(call => __.conn.hdel(table, key1, call));
                                                        data.push([{
                                                            value: 1
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "zlen":
                                            case "zcount":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    let limita = parseInt(v.LimitParam && v.LimitParam['_0'] && v.LimitParam[v.LimitParam['_0']]) || '-inf';
                                                    let limitb = parseInt(v.LimitParam && v.LimitParam['_1'] && v.LimitParam[v.LimitParam['_1']]) || null;!limitb ? (limitb = '+inf') : (limitb = limita + limitb - 1);
                                                    let calls = call => __.conn.zcount(table, limita, limitb, call);

                                                    if (trans) {
                                                        transfunc.push(calls);
                                                    } else {
                                                        try {
                                                            const res = await V.callback(calls);
                                                            data.push([{ count: res }]);
                                                        } catch (e) {
                                                            data.push([{ count: 0 }]);
                                                        }
                                                    }
                                                }
                                                break;
                                            case "zselect":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    let keyID = Object['keys'](v.IDs)[0],
                                                        key = null;
                                                    const orders = (() => {
                                                        if (v.OrderParam)
                                                            for (let k in v.OrderParam) return v.OrderParam[k];
                                                        else return 'asc';
                                                    })() || 'asc';
                                                    let limita = parseInt(v.LimitParam && v.LimitParam['_0'] && v.LimitParam[v.LimitParam['_0']]) || 0;
                                                    let limitb = parseInt(v.LimitParam && v.LimitParam['_1'] && v.LimitParam[v.LimitParam['_1']]) || null;!limitb ? (limitb = limita - 1, limita = 0) : (limitb = limita + limitb - 1);
                                                    let scorea = null,
                                                        scoreb = null;
                                                    if (v.WhereParam) {
                                                        const node = [v.WhereParam];
                                                        while (node.length) {
                                                            var _node = node.pop();
                                                            for (let k in _node) {
                                                                let v2 = _node[k];
                                                                if (v2 && v2.score)
                                                                    switch (k) {
                                                                        case '<':
                                                                            scoreb = '(' + v2.score;
                                                                            break;
                                                                        case '<=':
                                                                            scoreb = v2.score;
                                                                            break;
                                                                        case '>':
                                                                            scorea = '(' + v2.score;
                                                                            break;
                                                                        case '>=':
                                                                            scorea = v2.score;
                                                                            break;
                                                                        default:
                                                                            break;
                                                                    } else switch (k) {
                                                                        case 'score':
                                                                            scorea = v2;
                                                                            break;
                                                                        case keyID:
                                                                            key = v.IDs[keyID];
                                                                            break;
                                                                        default:
                                                                            node.push(v2);
                                                                            break;
                                                                    }
                                                            }
                                                        }
                                                    }

                                                    let calls = null;
                                                    //console.log(2324, orders, table, scorea, scoreb, !scorea && !scoreb, limita, limitb);
                                                    if (key && key.length) {
                                                        calls = call => {
                                                            V.callback2(call2 => __.conn.zscore(table, key, call2)).then(v => {
                                                                call(null, [key, v]);
                                                            }).catch(call);
                                                        };
                                                    } else if (orders == 'asc') {
                                                        if (!scorea && !scoreb) {
                                                            //orders='zrange';
                                                            calls = call => __.conn.zrange(table, limita, limitb, "WITHSCORES", call);
                                                        } else {
                                                            calls = call => __.conn.zrangebyscore(table, scorea || '-inf', scoreb || '+inf', 'limit', limita, limitb, "WITHSCORES", call);
                                                        }

                                                    } else if (!scorea && !scoreb) {
                                                        //orders='zrange';
                                                        calls = call => __.conn.zrevrange(table, limita, limitb, "WITHSCORES", call);
                                                    } else {
                                                        calls = call => __.conn.zrevrangebyscore(table, scorea || '-inf', scoreb || '+inf', 'limit', limita, limitb, "WITHSCORES", call);
                                                    }
                                                    if (trans) {
                                                        transfunc.push(calls);
                                                    } else {
                                                        const res = await V.callback(calls);
                                                        try {
                                                            let _v = [];
                                                            res.forEach((v, i) => {
                                                                (i % 2 == 0) && (_v.push({ key: v, value: res[i + 1] }));
                                                                return null;
                                                            });
                                                            data.push(_v);
                                                            //console.log(2352, data);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case 'zrank':
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    var keys = v.IDs[Object['keys'](v.IDs)[0]];
                                                    const orders = (() => {
                                                        if (v.OrderParam)
                                                            for (let k in v.OrderParam) return v.OrderParam[k];
                                                        else return 'asc';
                                                    })() || 'asc';

                                                    let calls = null;
                                                    if (orders == 'asc') {
                                                        calls = call => __.conn.zrank(table, keys, call);
                                                    } else {
                                                        calls = call => __.conn.zrevrank(table, keys, call);
                                                    }
                                                    if (trans) {
                                                        transfunc.push(calls);
                                                    } else {
                                                        let res = await V.callback(calls);
                                                        try {
                                                            //console.log(2350, res, v, key);
                                                            if (null !== res) {
                                                                let _v = {};
                                                                _v[keys] = res + 1;
                                                                data.push(_v);
                                                            }
                                                            //console.log(2352, data);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case "zpop":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    var key = Object['keys'](v.IDs)[0];
                                                    const orders = (() => {
                                                        if (v.OrderParam)
                                                            for (let k in v.OrderParam) return v.OrderParam[k];
                                                        else return 'asc';
                                                    })() || 'asc';
                                                    let limita = parseInt(v.LimitParam && v.LimitParam['_0'] && v.LimitParam[v.LimitParam['_0']]) || 0;
                                                    let limitb = parseInt(v.LimitParam && v.LimitParam['_1'] && v.LimitParam[v.LimitParam['_1']]) || null;!limitb ? (limitb = limita - 1, limita = 0) : (limitb = limita + limitb - 1);

                                                    let calls = null;
                                                    //console.log(2324, orders, table, scorea, scoreb, 'limit', limita, limita + limitb - 1, );
                                                    if (orders == 'asc') {
                                                        calls = call => __.conn.zpopmin(table, limita, limitb, "WITHSCORES", call);
                                                    } else {
                                                        calls = call => __.conn.zpopmax(table, limita, limitb, "WITHSCORES", call);
                                                    }
                                                    if (trans) {
                                                        transfunc.push(calls);
                                                    } else {
                                                        let res = await V.callback(calls);
                                                        try {
                                                            //console.log(2350, res, v, key);
                                                            let _v = {};
                                                            V.isArray(res) ? (_v[res[0]] = res[1]) : (_v = res);
                                                            data.push(_v);
                                                            //console.log(2352, data);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            case "zinsert":
                                            case "zupdate":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    const score = parseInt(v.MethodParam.score && v.MethodParam.score.value || v.MethodParam.score) || 0;
                                                    var keys = v.IDs[Object['keys'](v.IDs)[0]];
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call))
                                                        transfunc.push(call => __.conn.zadd(table, score, keys, call));
                                                    } else {
                                                        await V.callback(call => __.conn.zadd(table, score, keys, call));
                                                        data.push([{
                                                            key: keys,
                                                            value: score
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "zincrease":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    const score = parseInt(v.MethodParam.score && v.MethodParam.score.value || v.MethodParam.score) || 0;
                                                    var keys = v.IDs[Object['keys'](v.IDs)[0]];
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call))
                                                        transfunc.push(call => __.conn.zincrby(table, score, keys, call));
                                                    } else {
                                                        var ret = await V.callback(call => __.conn.zincrby(table, score, keys, call));
                                                        data.push([{
                                                            key: keys,
                                                            value: ret
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "zdelete":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    var keys = v.IDs[Object['keys'](v.IDs)[0]];
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call));
                                                        transfunc.push(call => { return { value: __.conn.zrem(table, keys, call) } });
                                                    } else {
                                                        //console.log(2442);
                                                        data.push([{
                                                            value: await V.callback(call => __.conn.zrem(table, keys, call))
                                                        }]);
                                                    }
                                                }

                                                break;
                                            case "llen":
                                            case "lcount":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    if (trans) {
                                                        transfunc.push(call =>
                                                            __.conn.llen(table, call));
                                                    } else {
                                                        try {
                                                            let res = await V.callback(call => __.conn.llen(table, call));
                                                            data.push([{ count: res }]);
                                                        } catch (e) {
                                                            data.push([{ count: 0 }]);
                                                        }
                                                    }
                                                }
                                                break;
                                            case "lpop":
                                            case "lselect":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    let limit = (function() { for (var k in v.LimitParam) return v.LimitParam[k]; })();
                                                    if (typeof limit !== 'undefined') {
                                                        limit = limit.value || limit;
                                                        if (limit.type) throw new Error('lselect limit 请输入极限值!');
                                                    }

                                                    if (trans) {
                                                        transfunc.push(call =>
                                                            limit ? (function() {
                                                                let index = 0,
                                                                    datas = [];
                                                                V.whileC(() => index < limit ? index++ : null, function(i, call2) {
                                                                    __.conn.lpop(table, function(e, d) {
                                                                        d === null ? (index = limit) : datas.push(d);
                                                                        call2(e);
                                                                    })
                                                                }, true).then(function() {
                                                                    call(null, datas);
                                                                }).catch(call);
                                                            })() : __.conn.lpop(table, call));
                                                    } else {
                                                        let res = await V.callback(call => limit ? (function() {
                                                            let index = 0,
                                                                datas = [];
                                                            V.whileC(() => index < limit ? index++ : null, function(i, call2) {
                                                                __.conn.lpop(table, function(e, d) {
                                                                    d === null ? (index = limit) : datas.push(d);
                                                                    call2(e);
                                                                })
                                                            }, true).then(function() {
                                                                call(null, datas);
                                                            }).catch(call);
                                                        })() : __.conn.lpop(table, call));
                                                        try {
                                                            !V.isArray(res) && (res = res === null ? [] : [res]);
                                                            res.forEach(function(v, i) {
                                                                res[i] = ('' + v).startsWith('{') ? __.getValues(V.json(v), v.MethodParam) : v;
                                                            })
                                                            data.push(res);
                                                        } catch (e) {
                                                            for (let k in v.IDs) {
                                                                const ret2 = {};
                                                                ret2[k] = res;
                                                                data.push(ret2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }

                                                break;
                                            case "linsert":
                                            case "lupdate":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    const value = key1;
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call));
                                                        transfunc.push(call => __.conn.rpush(table, value, call));
                                                    } else {
                                                        await V.callback(call => __.conn.rpush(table, value, call));
                                                        data.push([{
                                                            value: 1
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "ldelete":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table));
                                                        transfunc.push(call => __.conn.lrem(table, 0, key1, call));
                                                    } else {
                                                        await V.callback(call => __.conn.lrem(table, 0, key1, call));
                                                        data.push([{
                                                            value: 1
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "dbs":
                                                {
                                                    if (trans) {
                                                        transfunc.push(call => __.conn.dbs(call));
                                                    } else {
                                                        const res = await V.callback(call => __.conn.dbs(call));
                                                        data.push([res]);
                                                    }
                                                }
                                                break;
                                            case "hngcrease":
                                                {
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    let values3 = {};
                                                    for (let k in v.MethodParam) {
                                                        if (!k) { continue; }
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values3[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }
                                                    let value3 = values3['_value'];
                                                    if (!(/^[1-9]+/.test(value3))) {
                                                        throw new Error(`参数_value必需为正整数`);
                                                    }
                                                    if (trans) {
                                                        transprefunc.push(call => __.conn.watch(table, call));
                                                        transfunc.push(call => __.conn.hngcrby(table, key1, -value3, value3, call));
                                                    } else {
                                                        var ret = await V.callback(call => __.conn.hngcrby(table, key1, -value3, value3, call));
                                                        data.push([{
                                                            value: ret
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case 'ngcrease':
                                                {
                                                    const values2 = {};
                                                    for (let k in v.MethodParam) {
                                                        let v2 = v.MethodParam[k];
                                                        v2 = typeof v2.value === 'undefined' ? v2 : v2.value;
                                                        values2[k] = v2;
                                                        if (typeof v2 === 'undefined' || v2.type) throw new Error(`参数${k}不能为undefined`);
                                                    }

                                                    const key2 = V.hash2(V.toJsonString(v.IDs)) + "";
                                                    let value2 = values2['_value'];
                                                    if (!(/^[1-9]+/.test(value2))) {
                                                        throw new Error(`参数_value必需为正整数`);
                                                    }
                                                    const majorkey2 = v.Table + key2;
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', majorkey2);
                                                    let func = null;
                                                    func = call => { __.conn.ngcrby(majorkey2, value2, call); }
                                                    if (trans) {
                                                        //transprefunc.push(call => __.conn.watch(majorkey2, call)
                                                        transfunc.push(func);
                                                    } else {
                                                        const res = await V.callback(func);
                                                        data.push([{
                                                            value: res
                                                        }]);
                                                    }
                                                }
                                                break;
                                            case "expire": //支持非普通字符串的key
                                                {
                                                    let datetime = Object.values(v.IDs)[0];
                                                    if (!datetime) {
                                                        throw new Error(`参数${v.IDs}不能为undefined`);
                                                    }
                                                    debug && console.log(v.Method.toLowerCase().trim(), 'key:', v.Table, '=>', table);
                                                    if (trans) {
                                                        transfunc.push(call => __.conn.expire(table, (parseInt(datetime) || 0) / 1000, call));
                                                    } else {
                                                        const res = await V.callback(call => __.conn.expire(table, (parseInt(datetime) || 0) / 1000, call));
                                                        data.push([res]);
                                                    }
                                                }
                                                break;
                                            default:
                                                throw new Error('NiRedisSqlDataFactory2 不支持的命令:' + v.Method);
                                        }
                                        return false;
                                    },
                                    true);


                                if (trans) {
                                    await V.each(transprefunc, async(v, call) => {
                                        await V.callback(v);
                                        return false;
                                    }, true);
                                    await __.conn.multi({
                                        pipeline: false
                                    });
                                    await V.each(transfunc, async(v, call) => {
                                        await V.callback(v);
                                        return false;
                                    }, true);
                                    const rets = await V.callback(call => __.conn.exec(call));
                                    await V.each(rets, v2 => {
                                        try {
                                            var jsdat = ('' + v2[1]).startsWith('{') ? V.json(v2[1]) : v2[1];
                                            if ('' + jsdat == '' + v2[1])
                                                data.push([{ value: jsdat }]);
                                            else data.push(jsdat);
                                        } catch (e) {
                                            data.push([{ value: v2[1] }]);
                                        }
                                        return false;
                                    });
                                }
                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                    _.params = {
                        connectionLimit: 10,
                        datetime: -1
                    };
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let data = [];
                        let cmds = __.cmds;
                        __.cmds = [];
                        await V.each(cmds, async v => {
                            data.push(await __.invoke(v.command, v.params));
                        }, true);
                        return data;
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);

                    __.host = _.params.host || '127.0.0.1';
                    __.port = _.params.port || 6379;
                    __.password = _.params.password || '';
                    __.timeout = _.params.timeout || 60000;
                    __.db = _.params.db || 0;
                    __.family = _.params.family || 4;

                    let redisargs = {
                        port: __.port, // Redis port 
                        host: __.host, // Redis host 
                        family: __.family, // 4 (IPv4) or 6 (IPv6) 
                        password: __.password,
                        db: __.db
                    }
                    __.conn = new Redis(redisargs);
                    __.conn.defineCommand('dbs', {
                        numberOfKeys: 0,
                        lua: "return redis.call('config','get','databases')[2]"
                    });
                    /**
                     *
                     * @desc 扣减库存Lua脚本
                     * 库存（stock）-1：表示不限库存
                     * 库存（stock）0：表示没有库存
                     * 库存（stock）大于0：表示剩余库存
                     *
                     * @params 库存key
                     * @return
                     *      0:库存不足
                     *      -1:库存未初始化
                     *      大于0:剩余库存（扣减之前剩余的库存）
                     *      redis缓存的库存(value)是-1表示不限库存，直接返回1
                     */
                    __.conn.defineCommand('hngcrby', {
                        numberOfKeys: 2,
                        lua: "if (redis.call('hexists', KEYS[1],KEYS[2]) == 1) then local stock = tonumber(redis.call('hget', KEYS[1],KEYS[2]));if (stock >= tonumber(ARGV[2])) then redis.call('hincrby', KEYS[1],KEYS[2],ARGV[1]);return stock;end;return 0;end;return -1;"
                    });
                    __.conn.defineCommand('ngcrby', {
                        numberOfKeys: 1,
                        lua: "if (redis.call('exists', KEYS[1]) == 1) then local stock = tonumber(redis.call('get', KEYS[1]));if (stock >= tonumber(ARGV[1])) then redis.call('decrby', KEYS[1],ARGV[1]);return stock;end;return 0;end;return -1;"
                    });
                    await super.open();
                }
                async close() {
                    const {
                        _,
                        __
                    } = pri(this);
                    try {
                        __.conn.end();
                    } catch (e) {}
                    __.cmds = [];
                    __.conn = null;
                    await super.close();
                }
            }
        });
        _.parser = parser;
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.RedisSqlConnection();
    };
    backDBConnection(conn) {
        conn.close();
    };
};
export const NiRedisSqlDataFactory = NiRedisSqlDataFactory2;

//todo  wcf

/**
 * NiUrlDataFactory
 * 自动调用远程URL
 */
export const NiUrlDataFactory = class extends NiDataFactory {
    constructor() {
        super();
        const that = this;
        that.regex = new RegExp('^((http|https):\\/\\/[\\w\\-_]+(\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\+#])?)$', 'i');
        const {
            _,
            __
        } = pri(that, {
            UrlConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const thats = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        host: "",
                        port: "",
                        method: "",
                        timeout: 60000,
                        invoke: async(command, params) => {
                            const {
                                _,
                                __
                            } = pri(thats);
                            try {
                                let args = (params.args ? params.args.value : params);
                                for (let i in args) {
                                    if (args[i].value) args[i] = args[i].value;
                                }
                                const func = (function() {
                                    switch ((args['_method'] || __.method).toLowerCase()) {
                                        case 'get':
                                            delete args['_method'];
                                            args = Q.stringify(args);
                                            return N.get;
                                        case 'post':
                                        default:
                                            delete args['_method'];
                                            args = Q.stringify(args);
                                            return N.post;
                                        case 'postjson':
                                            delete args['_method'];
                                            return N.postJson;
                                    }
                                })(); //立即执行函数获取返回值
                                let data = [];
                                await V.each(command.split(';'), async v => {
                                    v = v.trim();
                                    if (v.indexOf(':') < 0 && v.indexOf('//') < 0)
                                        v = (function() {
                                            let h = __.host.length > 0 ? __.host[V.random() % __.host.length] : __.host[0];
                                            if (h.indexOf(':') < 0 && h.indexOf('//') < 0)
                                                h = 'http://' + h;
                                            return h;
                                        })() + (V.isValid(__.port) && (__.port + "") != '80' ? ":" + __.port : "") + v;
                                    if (that.regex.test(v)) {
                                        const text = (await func(v, args)) || '';
                                        try {
                                            data.push([V.json(text)]);
                                        } catch (e) {
                                            data.push([{ text: text }]);
                                        }
                                    } else
                                        throw new Error(`错误的路径${v}`);
                                    return false;
                                }, true);
                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);
                    __.host = (_.params.host || '').split(';');
                    __.port = _.params.port || 80;
                    __.method = _.params.method || 'POST';
                    __.timeout = _.params.timeout || 60000;
                    await super.open();
                }
                async close() {
                    await super.close();
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let data = [];
                        let cmds = __.cmds;
                        __.cmds = [];
                        await V.each(cmds, async v => {
                            data.push(await __.invoke(v.command, v.params));
                            return false;
                        }, true);
                        return data;
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
            }
        });
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.UrlConnection();
    }
};

/**
 * NiSoapDataFactory
 * soap数据源支持
 */
export const NiSoapDataFactory = class extends NiDataFactory {
    constructor() {
        super();
        const that = this;
        const {
            _,
            __
        } = pri(that, {
            SoapConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const thats = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        host: "",
                        port: "",
                        method: "",
                        // control: "",
                        timeout: 60000,
                        invoke: async(command, params) => {
                            const { _, __ } = pri(thats);
                            var wcfurl = __.host;
                            var wcfmethod = command;
                            var wcfargs = {};
                            let args = (params.args ? params.args.value : params);
                            for (let i in args) {
                                wcfargs[i] = args[i].value;
                            }
                            var client = await V.callback2(S.createClient, S, wcfurl);
                            if (client && client[wcfmethod]) {
                                var ret = await V.callback2(client[wcfmethod], client, wcfargs) || {};
                                if (V.getType(ret).toLowerCase() != 'array') ret = [
                                    [ret]
                                ];
                                return ret;
                            } else
                                throw new Error(`获取client失败或者没有找到${wcfmethod}方法`);
                        }
                    });
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);

                    __.host = _.params.host || null;
                    __.port = _.params.port || 80;
                    __.timeout = __.timeout || 60000;
                    await super.open();
                }
                async close() {
                    await super.close();
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let data = []
                        await V.each(__.cmds, async v => {
                            data.push(await __.invoke(v.command, v.params));
                            return false;
                        }, true);
                        __.cmds = [];
                        return data;
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
            }
        });
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.SoapConnection();
    }
};

/**
 * NiMailDataFactory
 * 自动调用Mail服务器发送邮件
 * https://www.npmjs.com/package/emailjs
 * {
            text: '测试内容2', // text of the email 
            from: '26342049@qq.com', // sender of the format (address or name <address> or "name" <address>)
            to: 'baibing0004@sohu.com', // recipients (same format as above), multiple recipients are separated by a comma
            cc: '', // carbon copied recipients (same format as above)
            bcc: '', // blind carbon copied recipients (same format as above)
            subject: '测试邮件', // string subject of the email
            attachment: [
                    { data: "<html>i <i>测试啊测试</i> this works!</html>", alternative: true },
                    { path: "/Users/&&&/Downloads/福岛核辐射.jpg", type: M2.get("福岛核辐射2.jpg"), name: "福岛核辐射2.jpg" }
                ]
                // one attachment or array of attachments
        }
 */
export const NiMailDataFactory = class extends NiDataFactory {
    constructor() {
        super();
        const that = this;
        const {
            _,
            __
        } = pri(that, {
            MailConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const thats = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        invoke: async(command, params) => {
                            const {
                                _,
                                __
                            } = pri(thats);
                            if (!__.conn) throw new Error('请先连接Mail服务器');
                            let args = (params.args ? params.args.value : params);
                            for (let i in args) {
                                if (args[i].value) args[i] = args[i].value;
                            }
                            try {
                                let data = [];
                                await V.callback(__.conn.send, __.conn, args);
                                data.push([{
                                    success: true
                                }])
                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);
                    //user:	"username",   password:"password",  host:	"smtp.your-email.com",
                    __.conn = Mail.server.connect(V.merge({
                        ssl: true
                    }, _.params));
                    await super.open();
                }
                async close() {
                    __.conn = null;
                    await super.close();
                }
                async invoke(cmd) {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        let data = [];
                        let cmds = __.cmds;
                        __.cmds = [];
                        await V.each(cmds, async v => {
                            data.push(await __.invoke(v.command, v.params));
                        }, true);
                        return data;
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
            }
        });
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.MailConnection();
    }
};

/**
 * es 池连接方式工厂
 */
export const NiElasticSearchDataFactory = class extends NiDataFactory {
    constructor() {
        super();
        const that = this;
        that.idic = {};
        const {
            _,
            __
        } = pri(that, {
            ElasticSearchConnection: class extends NiDataConnection {
                constructor() {
                    super();
                    const that = this;
                    const {
                        _,
                        __
                    } = pri(this, {
                        cmds: [],
                        conn: null,
                        invoke: async(command, params) => {
                            try {
                                const {
                                    _,
                                    __
                                } = pri(that);
                                let args = (params.args ? params.args.value : params);
                                for (let i in args) {
                                    if (args[i].value) args[i] = args[i].value;
                                }

                                const result = await V.callback(__.conn.create, __.conn, V.merge({
                                        index: '',
                                        type: 'logs',
                                        id: '',
                                        body: {
                                            title: '',
                                            message: ''
                                        }
                                    },
                                    args));

                                let data = [];
                                data.push([{
                                    success: true
                                }]);

                                return data;
                            } catch (e) {
                                console.log(command, params);
                                console.log(e.message);
                                throw e;
                            }
                        }
                    });
                    _.params = {
                        host: ''
                    };
                }
                async invoke(cmd) {
                    //需要处理单条与多条s
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        __.cmds.push({
                            command: cmd.command,
                            params: cmd.params
                        });
                    } else
                        return await __.invoke(cmd.command, cmd.params);
                }
                async commit() {
                    const {
                        _,
                        __
                    } = pri(this);
                    if (_.transaction) {
                        //事务性处理
                        try {
                            let data = [];
                            let cmds = __.cmds;
                            __.cmds = [];
                            await V.each(cmds, async v => {
                                //console.log(v.cmd.params);
                                data.push(await __.invoke(v.command, v.params));
                                return false;
                            }, true);
                            return data;
                        } catch (e) {
                            throw e;
                        }
                    } else
                        throw new Error('非事务条件下不可调用此方法');
                }
                async open() {
                    const {
                        _,
                        __
                    } = pri(this);
                    __.conn = new es.Client(V.merge({
                        log: 'trace'
                    }, _.params));
                    await super.open();
                }
                async close() {
                    const {
                        _,
                        __
                    } = pri(this);
                    try {
                        if (__.conn && __.conn.release)
                            __.conn.release();
                        else if (__.conn && __.conn.end)
                            __.conn.end();
                        else if (__.conn && __.conn.dispose)
                            __.conn.dispose();
                    } catch (e) {}
                    __.cmds = [];
                    __.conn = null;
                    await super.close();
                }
            }
        });
    }
    createDBConnection() {
        const {
            _,
            __
        } = pri(this);
        return new __.ElasticSearchConnection();
    }
    dispose() {
        const {
            _,
            __
        } = pri(this);
        V.tryC(() => {
            __.conn.dispose();
        });
    }
};

export default {
    NiDataConfig,
    NiDataConfigConvert,
    NiTemplate,
    NiTemplateManager,
    NiDataResult,
    NiDataResource,
    NiInstanceDataResource,
    NiStaticDataResource,
    NiPoolDataResource,
    NiDataFactory,
    NiDataConnection,
    NiDataCommand,
    NiTemplateDecorator,
    NiMultiTemplateDecorator,
    NiMySQLDataFactory,
    NiMsSQLDataFactory,
    NiObjectDataFactory,
    NiUrlDataFactory,
    NiMailDataFactory,
    NiRedisSqlDataFactory,
    NiRedisSqlDataFactory2,
    NiSoapDataFactory,
    NiMemSQLDataFactory
};