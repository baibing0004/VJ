import V from '../common/tool';
export const QueryEntity = class {
    constructor(sign) {
        const that = this;
        const {
            _,
            __
        } = pri(this);
        _.IDs = {};
        _.MethodParam = {};
        _.WhereParam = {};
        _.OrderParam = {};
        _.SkipParam = {};
        _.LimitParam = {};
        _.DateTimeParam = {};
        _.Method = null;
        _.Params = {};
        _.Table = '';
        _.sign = sign;
    }
    addParams(p, ret) {
        const {
            _,
            __
        } = pri(this);
        p = p.trim();
        if (_.Params[p]) {
            let hasData = false;
            _.Params[p].forEach(v => {
                if (v == ret) hasData = true;
            });
            if (!hasData) _.Params[p].push(ret);
        } else {
            _.Params[p] = [ret];
        }
    }
    clone() {
        const {
            _,
            __
        } = pri(this);
        let ret = new QueryEntity();
        V.merge(ret.IDs, _.IDs, true);
        V.merge(ret.MethodParam, _.MethodParam, true);
        V.merge(ret.WhereParam, _.WhereParam, true);
        V.merge(ret.OrderParam, _.OrderParam, true);
        V.merge(ret.SkipParam, _.SkipParam, true);
        V.merge(ret.DateTimeParam, _.DateTimeParam, true);
        V.merge(ret.LimitParam, _.LimitParam, true);
        for (let k in ret.IDs) {
            let v = ret.IDs[k];
            if (v && v.startWith && v.startWith(_.sign)) ret.addParams(v.trim(_.sign), ret.IDs);
        }
        for (let k in ret.MethodParam) {
            let v = ret.MethodParam[k];
            if (v && v.startWith && v.startWith(_.sign)) ret.addParams(v.trim(_.sign), ret.MethodParam);
        }
        for (let k in ret.OrderParam) {
            let v = ret.OrderParam[k];
            if (v && v.startWith && v.startWith(_.sign)) ret.addParams(v.trim(_.sign), ret.OrderParam);
        }
        for (let k in ret.SkipParam) {
            let v = ret.SkipParam[k];
            if (v && v.startWith && v.startWith(_.sign)) ret.addParams(v.trim(_.sign), ret.SkipParam);
        }
        for (let k in ret.DateTimeParam) {
            let v = ret.DateTimeParam[k];
            if (v && v.startWith && v.startWith(_.sign)) ret.addParams(v.trim(_.sign), ret.DateTimeParam);
        }
        for (let k in ret.LimitParam) {
            let v = ret.LimitParam[k];
            if (v && v.startWith && v.startWith(_.sign)) ret.addParams(v.trim(_.sign), ret.LimitParam);
        }
        ___.func(ret.WhereParam, ret, _.sign);
        ret.Method = _.Method;
        ret.Table = _.Table;
        ret.sign = _.sign;
        return ret;
    }
};
export const LinqParser = class {
    constructor(sign = "?") {
        const {
            _,
            __
        } = pri(this, {
            dicQuery: {}
        });
        _.sign = sign;
    }
    parse(sql, params = {}) {
        const {
            _,
            __
        } = pri(this);
        const key = 'K' + V.hash(sql);
        if (__.dicQuery[key]) {} else {
            var rets = sql.split(';').filter(v => V.isValid(v));
            rets.forEach((v, i) => rets[i] = (v ? _.singleparse(v) : null));
            __.dicQuery[key] = rets;
        }
        let ret = [];
        __.dicQuery[key].forEach(v => {
            if (v) {
                let entity = v.clone();
                for (let k in entity.Params) {
                    const v = entity.Params[k];
                    (entity.IDs[k] && !params[k]) && (params[k] = { value: '' }); //为hgets hkeys 添加默认值
                    let val = (params[k] && params[k].value !== undefined) ? params[k].value : params[k];
                    let key = _.sign + k;
                    if (val !== undefined && val !== null) {} else throw new Error('没有找到需要的参数值' + key);
                    v.forEach(v2 => {
                        for (let k3 in v2) {
                            if (v2[k3] == key) v2[k3] = val;
                        }
                    });
                }

                if (entity.Table && entity.Table.indexOf('{') >= 0) entity.Table = entity.Table.replace(/\{[^\}]+\}/g, k => {
                    let k2 = (k.substr(1, k.length - 2));
                    let ret = params[k2] ? (params[k2].value || (params[k2].type ? '' : params[k2])) : k;
                    if (ret.startWith(_.sign) && params[ret.trim(_.sign)]) {
                        k2 = ret.trim(_.sign);
                        ret = params[k2] ? (params[k2].value || (params[k2].type ? '' : params[k2])) : k;
                    }
                    return ret;
                });

                ret.push(entity);
            }
        });
        return ret;
    }

    singleparse(sql) {
        const {
            _,
            __
        } = pri(this);
        if (sql) {
            const entity = new QueryEntity(_.sign);
            let sqls = sql.split('.');
            let v = sqls.shift();
            while (!V.isValid(v))(v = sqls.shift());
            (v && 'transaction'.eq(v.trim())) && (entity.Method = 'transaction', v = sqls.shift());
            if (v) {
                //设置表名
                v = v.trim();
                if (v.indexOf('<') >= 0) {
                    let tabs = v.split('<');
                    entity.Table = tabs[0].trim();
                    tabs[1].trim('>').split(',').forEach(f => {
                        f = f.trim(_.sign);
                        entity.IDs[f] = _.sign + f;
                        entity.addParams(f, entity.IDs);
                    });
                } else {
                    entity.Table = v.trim();
                }
                v = sqls.shift();
            }
            if (v && !V.isValid(entity.Method)) {
                v = v.trim();
                let method = v.toLowerCase().split('(')[0];
                switch (method) {
                    case 'select':
                    case 'hselect':
                    case 'hmselect':
                    case 'hkeys':
                    case 'hgets':
                    case "zlen":
                    case "zcount":
                    case 'zselect':
                    case 'zpop':
                    case 'zrank':
                    case 'lselect':
                    case 'lpop':
                    case 'lcount':
                    case 'llen':
                    case 'dbs':
                    case 'hkeys':
                    case 'hlen':
                    case 'hcount':
                    case 'expire':
                    case "delete":
                    case "hdelete":
                    case "zdelete":
                    case "ldelete":
                        handleMethodStartWith(v, method, entity);
                        break;
                    case 'insert':
                    case 'hinsert':
                    case 'zinsert':
                    case 'linsert':
                    case 'hupdate':
                    case 'zupdate':
                    case 'lupdate':
                    case 'hngcrease':
                    case 'ngcrease':
                    case 'lock':
                    case 'hlock':
                        handleMethodStartWith(v, method, entity, _.sign);
                        break;
                    case 'update':
                        handleMethodStartWith(v, 'insert', entity, _.sign);
                        break;
                    case 'increase':
                    case 'hincrease':
                    case 'zincrease':
                        {
                            entity.Method = method.startWith("i") ? "increase" : method.startWith("z") ? "zincrease" : "hincrease";
                            v = v.substr(entity.length).trim('(').trim(')').trim();
                            if (!(!V.isValid(v) || "*" == (v))) {
                                v.split(',').forEach(f => {
                                    if (!V.isValid(f)) return;
                                    f = f.trim();
                                    let p3 = f.split('=');
                                    if (p3.length < 2) throw new Error("SQL在\"" + v.substr(v.indexOf(f)) + "\"处解析错误!\r\n:" + f + "没有找到=号");
                                    entity.MethodParam[p3[0].trim()] = p3[1].trim();
                                    if (p3[1].trim().startWith(_.sign)) {
                                        entity.addParams(p3[1].trim(_.sign), entity.MethodParam);
                                    }
                                });
                            } else
                                throw new Error("SQL在\"" + v.substr(v.indexOf('.')) + "\"处解析错误!\r\n:\r\n:没有找到可插入的列及其值");
                        }
                        break;
                    default:
                        //错误
                        throw new Error("SQL在\"" + v.substr(v.indexOf('.')) + "\"处解析错误!\r\n:没有找到可解析的操作指令");

                }
                //设置操作
                v = sqls.shift();
            }

            if (v && v.toLowerCase().startWith("where")) {
                //这里需要判断 where skip limit
                v = v.trim();
                //region where(a1 = 1 and b=2 or c=3 and d=4 and ())
                //= > >= < <= <> 第一优先级 然后是 () 然后是 and 然后是 or 再添加对not的处理
                let ht = {};
                let w = 0;
                //取消)号 由(号识别其结束符
                "=,>,<,>=,<=,<>,not,and,or,(,;,in".split(',').forEach(f => ht[f] = w++);
                ht[','] = w++;
                //todo in和,号

                /*
                 * 解释器+责任链式处理思路
                 * 缓存分为 非逻辑字符 与 已完成逻辑操作两个变量 和 未完成逻辑操作栈 保留未完成的操作
                 * LogicOperate 其每次 lIncome 非逻辑字符，已完成逻辑操作 rIncome 非逻辑字符，已完成逻辑操作与未处理字符，
                 * 如果发现此逻辑字符不为自己所能处理 将自己压栈等待下一个逻辑操作完成，当下一个操作完成时自动弹出下个操作调用将自己作为其另一种右进操作，直到语句结束 
                 * 发现字符未处理完成或者栈内仍然有未处理的操作 报错，如果缓存字符，已完成逻辑操作超过1个报错
                 **/
                let session = new OperationSession();
                let p3 = v.trim();
                p3 = p3.substr(6, p3.length - 7);
                p3 = p3.replace(/=/g, " = ");
                p3 = p3.replace(/>/g, " > ");
                p3 = p3.replace(/</g, " < ");
                p3 = p3.replace(/\(/g, " ( ");
                p3 = p3.replace(/\)/g, " ) ");
                p3 = p3.replace(/<\s*>/g, " <> ");
                p3 = p3.replace(/>\s*=/g, " >= ");
                p3 = p3.replace(/<\s*=/g, " <= ");
                p3 = p3.replace(/\s+/g, ' ');
                p3.split(' ').forEach(f => {
                    try {
                        if (!V.isValid(f)) return;
                        if (ht[f.toLowerCase()] >= 0) {
                            let index = ht[f.toLowerCase()];
                            let ope = null;
                            if (index < 1) {
                                //表达式
                                ope = new EqualOperate();
                            } else if (index < 6) {
                                ope = new O1Operate(f);
                            } else if (index < 7) {
                                ope = new NotOperate();
                            } else if (index < 8) {
                                ope = new AndOperate();
                            } else if (index < 9) {
                                //处理or
                                ope = new O2Operate(f);
                            } else if (index < 10) {
                                //处理括号
                                ope = new LCOperate();
                            }
                            if (ope == null) throw new Error("发现暂时无法处理的操作符号" + f);
                            ope.lIncome(session);
                        } else {
                            //临时存放字符否则弹出操作栈进行右入处理
                            if (session.OperateStack.length == 0) session.Word = f;
                            else session.OperateStack.pop().rIncome(session, f);
                        }
                    } catch (ex) {
                        throw new Error("SQL在\"" + p3.substr(p3.indexOf(" " + f + " ")) + "\"处解析错误!\r\n:" + ex.message);
                    }
                });
                if (session.isComplete) {
                    let ope = session.CompleteOperate;
                    entity.WhereParam = ope.toDictionary(entity, _.sign);
                    let func = (data) => {
                        for (let k in data) {
                            let v = data[k];
                            if (v.startWith) {
                                if (v.startWith(_.sign)) {
                                    entity.addParams(v.trim(_.sign), data);
                                }
                            } else if (typeof(v) == 'object') {
                                func(v);
                            }
                        }
                    };
                    func(entity.WhereParam);
                } else
                    throw new Error("SQL在\"" + p3.substr(p3.indexOf(" " + session.Word + " ")) + "\"处解析错误!\r\n:语句未完成");

                v = sqls.shift();
            }

            if (v && v.startWith("order")) {
                v = v.trim();
                //#region order(a1 asc,b1 desc)
                let p4 = v.trim(')').split('(');
                if (p4.length < 2) {
                    throw new Error("SQL在\"" + p3.substr(p3.indexOf(".order")) + "\"处解析错误!\r\n:skip没有找到可用的参数");
                }
                p4[1].split(',').forEach(f => {
                    let f2 = f.split(' ');
                    entity.OrderParam[f2[0].trim()] = f2.length < 2 ? "asc" : f2[1].trim();
                });
                v = sqls.shift();
                //#endregion
            }

            if (v && v.startWith("skip")) {
                v = v.trim();
                //#region skip(@page) skip(11)
                //todo 支持表达式
                let p4 = v.trim(')').split('(');
                if (p4.length < 2) {
                    throw new Error("SQL在\"" + p3.substr(p3.indexOf(".skip")) + "\"处解析错误!\r\n:skip没有找到可用的参数");
                }
                entity.SkipParam[p4[1].trim(_.sign)] = p4[1]
                if (p4[1].startWith(_.sign)) entity.addParams(p4[1].trim(_.sign), entity.SkipParam);

                v = sqls.shift();
                //#endregion
            }

            if (v && v.startWith("limit")) {
                v = v.trim();
                //#region limit(@page) limit(11)
                //todo 支持表达式
                let p4 = v.trim(')').split('(');
                if (p4.length < 2) {
                    throw new Error("SQL在\"" + p3.substr(p3.indexOf(".limit")) + "\"处解析错误!\r\n:skip没有找到可用的参数");
                }
                p4[1].split(',').forEach(function(v2, i) {
                    entity.LimitParam[v2.trim(_.sign)] = v2;
                    entity.LimitParam['_' + i] = v2.trim(_.sign);
                    if (v2.startWith(_.sign)) entity.addParams(v2.trim(_.sign), entity.LimitParam);
                });

                v = sqls.shift();
                //#endregion
            }

            if (v && (v.startWith("datetime") || v.startWith("timeout"))) {
                v = v.trim();
                //#region datetime(@time) datetime(200) timeout(@time) timeout(2000)
                //todo 支持表达式
                let p4 = v.trim(')').split('(');
                if (p4.length < 2) {
                    throw new Error("SQL在\"" + p3.substr(p3.indexOf("datetime")) + "\"处解析错误!\r\n:skip没有找到可用的参数");
                }
                entity.DateTimeParam[p4[1].trim(_.sign)] = p4[1]
                if (p4[1].startWith(_.sign)) entity.addParams(p4[1].trim(_.sign), entity.DateTimeParam);

                v = sqls.shift();
                //#endregion
            }

            if (v)
                throw new Error("SQL在\"" + p3.substr(p3.indexOf("." + v)) + "\"处解析错误!\r\n:没有找到可解析的操作指令");
            return entity;
        } else throw new Error('sql必须有值!');
    }
};

/**
 * 处理Method时，统一处理
 * v: 传进来的方法名，如：select开头，hselect开头，insert开头等
 * method:  nosql对应的操作方法
 * entity:转换后的实体
 * sign:
 */
function handleMethodStartWith(v, method, entity, sign) {
    entity.Method = method;
    v = v.substr(method.length).trim('(').trim(')').trim();
    switch (method) {
        case 'select':
        case 'hselect':
        case 'hmselect':
        case "zlen":
        case "zcount":
        case 'zselect':
        case 'zpop':
        case 'zrank':
        case 'hkeys':
        case 'hgets':
        case 'lpop':
        case 'lselect':
        case 'llen':
        case 'lcount':
        case 'hlen':
        case 'hcount':
        case 'dbs':
            if (!(!V.isValid(v) || "*" == (v))) {
                v.split(',').forEach(f => {
                    if (!V.isValid(f)) return;
                    entity.MethodParam[f] = 1;
                });
            }
            break;
        case 'insert':
        case 'hinsert':
        case 'zinsert':
        case 'linsert':
        case 'hngcrease':
        case 'ngcrease':
        case 'update':
        case 'hupdate':
        case 'zupdate':
        case 'lupdate':
        case 'expire':
        case 'lock':
        case 'hlock':
            if (!(!V.isValid(v) || "*" == (v))) {
                v.split(',').forEach(f => {
                    if (!V.isValid(f)) return;
                    f = f.trim();
                    let p3 = f.split('=');
                    if (p3.length < 2) throw new Error("SQL在\"" + v.substr(v.indexOf(f)) + "\"处解析错误!\r\n:" + f + "没有找到=号");
                    entity.MethodParam[p3[0].trim()] = p3[1].trim();
                    if (p3[1].trim().startWith(sign)) {
                        entity.addParams(p3[1].trim(sign), entity.MethodParam);
                    }
                });
            } else
                throw new Error("SQL在\"" + v.substr(v.indexOf('.')) + "\"处解析错误!\r\n:\r\n:没有找到可插入的列及其值");
            break;
        case 'delete':
        case 'hdelete':
        case 'zdelete':
        case 'ldelete':
            if (!(!V.isValid(v) || "*" == (v))) {
                throw new Error("SQL在\"" + v.substr(v.indexOf('.')) + "\"处解析错误!\r\n:\r\n:不需要设置可删除的列及其值");
            }
            break;
    }
};
export const NoSQLParser = class extends LinqParser {
        constructor(sign) {
            super(sign);
            const {
                _,
                __
            } = pri(this);
        }
        singleparse(sql) {
            const {
                _,
                __
            } = pri(this);
            let sss = sql.replace(/\(/g, ' ( ').replace(/\)/g, ' ) ');
            //将多个空格,换行换成一个空格
            let item1 = sss.replace(/\s+/g, ' ');
            //取关键点索引位置
            let temp = item1.toLowerCase();
            let from1 = temp.indexOf(" from ");
            let where1 = temp.indexOf(" where ");
            let skip1 = temp.indexOf(" skip ");
            let limit1 = temp.indexOf(" limit ");
            let order1 = temp.indexOf(" order ");
            let by1 = temp.indexOf(" by ");
            let set1 = temp.indexOf(" set ");
            let into1 = temp.indexOf(" into ");
            let values1 = temp.indexOf(" values ");
            let dateTime1 = temp.indexOf(" datetime ");
            let begintrans = temp.indexOf("begin transaction");
            let whereMember = "";
            let method = "";
            let methodMember = "";
            let tableStr = "";
            let orderby = "";
            let sk = null;
            let lm = null;
            let date = null;

            //语句中包含from
            if (from1 != -1) {
                let s = item1.substr(0, from1).trim().split(' ');
                if (s.length >= 2) {
                    method = s[0].trim().toLowerCase();
                    methodMember = s[1].trim();
                } else method = s[0].trim().toLowerCase();
            }
            //语句中不包含from但包含set,update语句处理
            if (set1 != -1 && from1 == -1) {
                let s = item1.substr(0, set1).trim().split(' ');
                method = s[0].trim().toLowerCase();
                tableStr = s[1].trim();
                if (where1 != -1) {
                    methodMember = item1.substr(set1 + 4, where1 - set1 - 4).trim();
                } else {
                    methodMember = item1.substr(set1 + 4).trim();
                }
            }
            //插入语句处理
            if (from1 == -1 && into1 != -1 && set1 == -1) {
                method = item1.substr(0, into1).trim().toLowerCase();
                if (values1 != -1) {
                    let s = item1.substr(into1 + 5, values1 - into1 - 5).trim().split(' ');
                    tableStr = s[0].trim();
                    for (let i = 1; i < s.length; i++) {
                        methodMember += s[i].trim();
                    }

                    let tp;
                    if (dateTime1 != -1) {
                        tp = item1.substr(values1 + 7, dateTime1 - values1 - 7).replace(/\(/g, "").replace(/\)/g, "").trim().split(',');
                        date = item1.substr(dateTime1 + 9).replace(/\(/g, "").replace(/\)/g, "").trim(';').trim();
                    } else
                        tp = item1.substr(values1 + 7).replace(/\(/g, "").replace(/\)/g, "").trim().split(',');
                    let tt = new V.sb();
                    let mem = methodMember.replace(/\(/g, "").replace(/\)/g, "").split(',');
                    for (let i = 0; i < mem.length; i++) {
                        tt.append(mem[i] + "=" + tp[i] + ",");
                    }
                    methodMember = tt.clear().trim(',');
                }
            }

            let sb = new V.sb();
            //取表名
            if (where1 != -1 && from1 != -1) tableStr = item1.substr(from1 + 5, where1 - from1 - 5).trim();
            if (where1 == -1 && set1 == -1 && from1 != -1) tableStr = item1.substr(from1 + 5).trim().split(' ')[0];
            if (begintrans != -1) {
                method = 'transaction';
            }
            //只支持增删改查
            switch (method) {
                case "select":
                case "increase":
                case "delete":
                case "update":
                case "insert":
                case 'lock':
                case "touch":
                case "transaction":
                case "hselect":
                case 'hmselect':
                case "hincrease":
                case "zlen":
                case "zcount":
                case "zselect":
                case 'zpop':
                case 'zrank':
                case "zincrease":
                case "lselect":
                case "llen":
                case "lcount":
                case "hkeys":
                case 'hlen':
                case 'hcount':
                case "hgets":
                case 'hlock':
                case "dbs":
                case "lpop":
                case "zinsert":
                case "linsert":
                case "hinsert":
                case "zupdate":
                case "lupdate":
                case "hupdate":
                case "hdelete":
                case "ldelete":
                case "zdelete":
                case "hngcrease":
                case "ngcrease":
                case "expire":
                    break;
                default:
                    throw new Error("只支持select,insert,lock,update,delete,touch,transaction,hselect,hmselect,zlen,zcount,zselect,zpop,zrank,zincrease,lselect,lpop,llen,lcount,hkeys,hgets,hlen,hcount,zinsert,linsert,hlock,hinsert,hdelete,ldelete,zdelete,hngcrease,dbs,ngcrease,expire.请检查查询语句" + method);
            }
            sb.append(tableStr + "." + method);
            if (!(methodMember.indexOf("*") >= 0 || !V.isValid(methodMember))) sb.append("(" + methodMember + ")");
            if (dateTime1 != -1 && date != null) sb.append(".datetime(" + date + ")");
            //排序处理
            if (order1 != -1) {
                if (where1 != -1) {
                    whereMember = item1.substr(where1 + 6, order1 - where1 - 6).trim();
                    sb.append(".where(" + whereMember + ")");
                }
                if (skip1 != -1) {
                    orderby = item1.substr(by1 + 3, skip1 - by1 - 3).trim();
                    if (orderby.indexOf(_.sign) >= 0)
                        throw new Error("排序中不允许参数化");
                }
                if (skip1 == -1 && limit1 != -1) {
                    orderby = item1.substr(by1 + 3, limit1 - by1 - 3).trim();
                }
                if (skip1 == -1 && limit1 == -1 && dateTime1 == -1) {
                    orderby = item1.substr(by1 + 3).trim();
                }
                if (orderby.indexOf(_.sign) >= 0)
                    throw new Error("排序中不允许参数化");
                sb.append(".order(" + orderby + ")");
            } else if (where1 != -1) {
                if (skip1 == -1 && limit1 == -1 && into1 == -1 && dateTime1 == -1) {
                    whereMember = item1.substr(where1 + 6).trim();
                    sb.append(".where(" + whereMember + ")");
                } else if (skip1 != -1) {
                    whereMember = item1.substr(where1 + 6, skip1 - where1 - 6).trim();
                    sb.append(".where(" + whereMember + ")");
                } else if (skip1 == -1 && limit1 != -1) {
                    whereMember = item1.substr(where1 + 6, limit1 - where1 - 6).trim();
                    sb.append(".where(" + whereMember + ")");
                }
            }
            //跳转处理
            if (skip1 != -1) {
                if (limit1 != -1) {
                    sk = item1.substr(skip1 + 5, limit1 - 5 - skip1).trim();
                    sb.append(".skip(" + sk + ")");
                } else if (dateTime1 == -1 && limit1 == -1) {
                    sk = item1.substr(skip1 + 5).trim();
                    sb.append(".skip(" + sk + ")");
                }
            }
            //限制条数处理
            if (limit1 != -1 && dateTime1 == -1) {
                lm = item1.substr(limit1 + 6).trim();
                sb.append(".limit(" + lm + ")");
            }
            const p = sb.clear();
            sb = null;
            return super.singleparse(p);
        };
    }
    /*
    export const addParams = (ret, value, entity, sign) => {
        //仅仅补充Level为1时的状态                    
        if (typeof(value) == 'object' && V.toJsonString(value).startWith('{')) {
            for(let k in value){
                let v = value[k];
                if ((v + '').startWith(sign)) {
                    entity.addParams(v + '', value);
                }
            });
        } else if (V.isArray(value)) {
            //对这种2级操作符之间的嵌套不做处理
        } else {
            if ((value + '').startWith(sign)) {
                entity.addParams(value + '', ret);
            }
        }
    };*/
export const OperationSession = class {
    constructor() {
        const {
            _,
            __
        } = pri(this, {
            word: null,
            regWord: new RegExp('^[a-zA-Z_\\$]+[a-zA-Z0-9_\\$]*$'),
            completeOperate: null
        });
        _.OperateStack = [];
    }
    set Word(val) {
        const {
            _,
            __
        } = pri(this);
        if (!V.isValid(val.match(__.regWord))) throw new Error('不能放入含非法字符的列名' + val);
        if (__.word) throw new Error("不能连续放入未处理字符");
        else __.word = val;
    }
    get Word() {
        const {
            _,
            __
        } = pri(this);
        let ret = __.word;
        __.word = null;
        return ret;
    }
    set CompleteOperate(val) {
        const {
            _,
            __
        } = pri(this);
        if (!V.isValid(__.completeOperate)) __.completeOperate = val;
        else throw new Error("不能连续放入已处理的Operator");

    }
    get CompleteOperate() {
        const {
            _,
            __
        } = pri(this);
        let ret = __.completeOperate;
        __.completeOperate = null;
        return ret;
    }
    get isComplete() {
        const {
            _,
            __
        } = pri(this);
        return (!V.isValid(__.word) && _.OperateStack.length == 0 && __.completeOperate != null);
    }
};
export const ALogicOperate = class {
    constructor(ope) {
        const {
            _,
            __
        } = pri(this, {});
        _.Ope = ope;
        _.level = 0;
    }
    lIncome(session) {}
    rIncome(session, word) {}
    rIncome2(session, ope) {}
    toDictionary(entity, sign) {}
}
export const O1Operate = class extends ALogicOperate {
    constructor(ope) {
        super(ope);
        const {
            _,
            __
        } = pri(this);
        _.level = 1;
        _.Key = null;
        _.Value = null;
    }
    lIncome(session) {
        const {
            _,
            __
        } = pri(this);
        _.Key = session.Word;
        if (!V.isValid(_.Key)) throw new Error(_.Ope + '不能没有对应的列');
        session.OperateStack.push(_);
        return true;
    }
    rIncome(session, word) {
        const {
            _,
            __
        } = pri(this);
        _.Value = word;
        if (!V.isValid(word)) throw new Error(_.Ope + "不能没有对应的值");
        if (session.OperateStack.length > 0) {
            //向上查找未完成操作的递归操作
            var ope = session.OperateStack.pop();
            if (ope.rIncome2(session, _)) return true;
            else {
                throw new Error(ope.Ope + "处理错误失败:" + word);
            }
        } else session.CompleteOperate = _;
        return true;
    }
    rIncome2(session, ope) {
        throw new Error("1级操作符不能处理逻辑表达式之间的关系");
    }
    toDictionary() {
        const {
            _,
            __
        } = pri(this);
        let ret = {};
        ret[_.Ope] = {};
        ret[_.Ope][_.Key] = _.Value;
        return ret;
    };
}
export const EqualOperate = class extends O1Operate {
    constructor() {
        super('=');
        pri(this);
    }
    toDictionary() {
        const {
            _,
            __
        } = pri(this);
        let ret = {};
        ret[_.Key] = _.Value;
        return ret;
    }
};

/**
 * 剩余的2级操作 and or not ( )
 */
export const O2Operate = class extends ALogicOperate {
    constructor(ope) {
        super(ope);
        const {
            _
        } = pri(this);
        _.level = 2;
        _.left = null;
        _.right = null;
    }
    lIncome(session) {
        const {
            _,
            __
        } = pri(this);
        _.left = session.CompleteOperate;
        if (_.left == null) throw new Error(_.Ope + " 不能直接处理非逻辑表达式");
        session.OperateStack.push(_);
        return true;
    }
    rIncome(session, word) {
        session.Word = word;
        session.OperateStack.push(this);
        return true;
    }
    rIncome2(session, ope) {
            const {
                _,
                __
            } = pri(this);
            _.right = ope;
            if (_.right == null) throw new Error(_.Ope + " 不能直接处理非逻辑表达式");
            if (session.OperateStack.length > 0) {
                //向上查找未完成操作的递归操作
                var ope2 = session.OperateStack.pop();
                if (ope2.rIncome2(session, _)) return true;
                else {
                    throw new Error(ope2.Ope + "处理错误失败");
                }
            } else session.CompleteOperate = this;
            return true;
        }
        /**
         * 目前只能处理1,2级混杂 不能处理连续2级
         */
    toDictionary(entity, sign) {
        const {
            _,
            __
        } = pri(this);
        var ret = {};
        var dicLeft = _.left.toDictionary(entity, sign);
        var dicRight = _.right.toDictionary(entity, sign);
        //当操作符一致时去壳可以并列于一个字典中
        if (_.left.Ope == (_.Ope)) {
            dicLeft = dicLeft[_.Ope];
        }
        if (_.right.Ope == (_.Ope)) {
            dicRight = dicRight[_.Ope];
        }

        //左侧原始值赋值并判断是否为真实
        V.merge(ret, dicLeft, true);
        V.merge(ret, dicRight, true);
        //保证一定不会有键值重复的可能
        var ret2 = {};
        ret2[_.Ope] = ret;
        return ret2;
    }
};
export const NotOperate = class extends O2Operate {
    constructor() {
        super('not');
        const {
            _
        } = pri(this);
    }
    lIncome(session) {
        const {
            _,
            __
        } = pri(this);
        if (V.isValid(session.Word) || session.CompleteOperate != null)
            throw new Error("not 处理错误,不允许存在前置的非2级表达式");
        session.OperateStack.push(_);
        return true;
    }
    toDictionary(entity, sign) {
        const {
            _,
            __
        } = pri(this);
        var ret = {};
        var dicRight = _.right.toDictionary(entity, sign);
        //左侧原始值赋值并判断是否为真实
        ret[_.Ope] = dicRight;
        return ret;
    }
};
/**
 * 特别处理and 当前面是已结束的or 时可能把自己放进去其右边
 */
export const AndOperate = class extends O2Operate {
    constructor() {
        super('and');
        pri(this);
    }
    lIncome(session) {
        const {
            _,
            __
        } = pri(this);
        _.left = session.CompleteOperate;
        if (_.left == null) throw new Error(_.Ope + " 不能直接处理非逻辑表达式");
        if ("or" == (_.left.Ope) && (_.left.right && _.left.right.level == 1)) {
            var orOpe = _.left;
            _.left = orOpe.right;
            orOpe.right = this;
            session.OperateStack.push(orOpe);
            session.OperateStack.push(_);
        } else session.OperateStack.push(_);
        return true;
    };
};
export const LCOperate = class extends O2Operate {
    constructor() {
        super('(');
        const {
            _
        } = pri(this);
        _.RealLogicOperate = null;
    }
    lIncome(session) {
        const {
            _,
            __
        } = pri(this);
        if (V.isValid(session.Word) || session.completeOperate != null) throw new Error("\"(\"处理错误,不允许存在前置的非2级表达式");
        session.OperateStack.push(_);
        return true;
    }
    rIncome(session, word) {
        const {
            _,
            __
        } = pri(this);
        if (")" == word) {
            _.RealLogicOperate = session.CompleteOperate;
            if (session.OperateStack.length > 0) {
                var ope = session.OperateStack.pop();
                ope.rIncome2(session, _);
            } else session.CompleteOperate = _;
        } else
            return super.rIncome(session, word);
        return true;
    };
    rIncome2(session, ope) {
        session.CompleteOperate = ope;
        session.OperateStack.push(this);
        return true;
    }
    toDictionary(entity, sign) {
        //todo 应该把$加在ope前面
        //return new Dictionary<string, object> { { _.Ope, RealLogicOperate.toDictionary(entity, sign) } };
        return this.RealLogicOperate.toDictionary(entity, sign);
    }
};
export default {
    QueryEntity,
    LinqParser,
    NoSQLParser,
    OperationSession,
    ALogicOperate,
    O1Operate,
    EqualOperate,
    O2Operate,
    NotOperate,
    AndOperate,
    LCOperate
};
const pri = V.pris();
const ___ = {
    func: (data, ret, sign) => {
        //参数化
        for (let k in data) {
            let v = data[k];
            if (v.startWith) {
                if (v.startWith(sign)) {
                    ret.addParams(v.trim(sign), data);
                }
            } else if (typeof(v) == 'object') {
                ___.func(v, ret, sign);
            }
        }
    }
}