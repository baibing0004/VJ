import V from '../common/tool';
import F from 'fs';
import P from 'path';
/**
 *
 */
export const formatPath = path => P.format(P.parse(P.resolve(P.normalize(path))));
export const execDir = () => P.parse(P.resolve(P.normalize(process.mainModule.filename))).dir;
export const createDir = function(target) {
    const tt = P.parse(P.resolve(P.normalize(target)));
    let sb = V.sb();
    let dirs = (tt.base.indexOf('.') >= 0 ? tt.dir : P.format(tt)).split(V.environment.splitChar);
    return V.each(dirs, async v => {
        sb.append(v + V.environment.splitChar);
        const path = sb.toString();
        if (!await V.callback(call => F.exists(path, ist => call(null, ist))))
            await V.callback(F.mkdir, F, path);
        return false;
    }, true);
};
export const copyFile = async function(source, target) {
    let istrue = await V.callback(call => F.exists(source, ist => call(null, ist)));
    if (istrue) {
        await createDir(target);
        await V.callback(call => {
            let tar = F.createWriteStream(target);
            tar.on('error', call);
            tar.on('finish', call);

            let src = F.createReadStream(source);
            src.pipe(tar);
        })
        return true;
    } else throw new Error(`源文件${source}没有找到`);
};
export const moveFile = async(source, target) => {
    await copyFile(source, target);
    await V.callback(F.unlink, F, source);
    return true;
};
export const copyDir = async function(source, target, isMove) {
    let tt = P.parse(P.resolve(P.normalize(target)));
    target = P.format(tt);
    tt = P.parse(P.resolve(P.normalize(source)));
    source = P.format(tt);
    let istrue = await V.callback((call) => F.exists(source, (istrue) => call(null, istrue)));
    if (istrue) {
        istrue = await V.callback((call) => F.exists(target, (istrue) => call(null, istrue)));
        if (!istrue && !(target.endWith('\\') || target.endWith('/'))) {
            await V.callback(F.mkdir, F, target);
        }
        const st = await V.callback(F.stat, F, source);
        if (!st.isDirectory()) throw new Error(`${source}不是文件夹`);
        else {
            let paths = await V.callback(F.readdir, F, source);
            await V.each(paths, async v => {
                let _src = `${source}/${v}`,
                    _dst = `${target}/${v}`;
                let st = await V.callback(F.stat, F, _src);
                if (st.isFile()) {
                    if (isMove) await moveFile(_src, _dst);
                    else await copyFile(_src, _dst);
                } else if (st.isDirectory()) {
                    if (isMove) await moveDir(_src, _dst);
                    else await copyDir(_src, _dst);
                }
                return false;
            }, true);
            return true;
        }
    } else throw new Error(`源文件夹${source}没有找到`);
}
export const moveDir = async(source, target) => {
    await copyDir(source, target, true);
    await V.callback(F.rmdir, F, source);
};

/**
 * 
 * @param {string} source 目标文件夹
 */
export const rmDir = async(source) => {
    let tt = P.parse(P.resolve(P.normalize(source)));
    source = P.format(tt);
    let istrue = await V.callback((call) => F.exists(source, (istrue) => call(null, istrue)));
    if (istrue) {
        const st = await V.callback(F.stat, F, source);
        if (!st.isDirectory()) throw new Error(`${source}不是文件夹`);
        else {
            let paths = await V.callback(F.readdir, F, source);
            await V.each(paths, async v => {
                let _src = `${source}/${v}`;
                let st = await V.callback(F.stat, F, _src);
                if (st.isFile()) {
                    await V.callback(F.unlink, F, _src);
                } else if (st.isDirectory()) {
                    await rmDir(_src);
                }
                return false;
            }, true);
            await V.callback(F.rmdir, F, source);
            return true;
        }
    } else throw new Error(`源文件夹${source}没有找到`);
};
export const checker = class {
    constructor(call) {
        const that = this;
        const { _, __ } = pri(that, {
            call: call,
            list: [],
            isEnd: false,
            check: () => {
                const { _, __ } = pri(that);
                if (!__.isEnd) {
                    let isF = true;
                    V.each(__.list, v => { isF = isF && v.isEnd; return false; }).then(() => {
                        if (isF) {
                            __.isEnd = true;
                            if (__.call) {
                                let f = __.call;
                                delete __.call;
                                V.each(__.list, v => { v.removeChecker(); return false; }).then(f);
                            }
                        }
                    });
                }
            }
        });
    }
    push(stream) {
        const { _, __ } = pri(this);
        const callback = () => {
            stream.isEnd = true;
            __.check();
        };
        stream.on('end', callback);
        stream.on('finish', callback);
        stream.removeChecker = () => {
            stream.removeListener('end', callback);
            stream.removeListener('finish', callback);
        };
        __.list.push(stream);
    }
};

/**
 * 对于流对象转换的简单实现
 * @param {*} s 
 * @param {*} t 
 */
export const transform = async function(s, t) {
    if (!s.pipe) throw new Error('源对象不是Stream类型!');
    if (!t.pipe) throw new Error('目标对象不是Stream类型!');
    return await V.callback(call => {
        t.on('error', call);
        t.on('finish', call);
        s.pipe(t);
    });
}
export const tranform = transform;
export default { formatPath, execDir, createDir, copyFile, moveFile, copyDir, moveDir, checker, transform, tranform, rmDir }
const pri = V.pris();