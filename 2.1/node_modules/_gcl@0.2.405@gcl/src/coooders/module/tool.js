import V from '../common/tool';
/**
 * gcd 使用辗转相除法获取最大公约数 http://blog.jobbole.com/106315/
 */
export const gcd = function(a, b) {
    if (a == b) return a;
    else if (a < b) return gcd(b, a);
    else {
        if ((a & 1) == 0 && (b & 1) == 0) {
            //偶数
            return gcd(a >> 1, b >> 1) << 1;
        } else if ((a & 1) == 0 && (b & 1) == 1) return gcd(a >> 1, b);
        else if ((a & 1) == 1 && (b & 1) == 0) return gcd(a, b >> 1);
        else return gcd(a - b, b);
    }
};
/**
 * tcd 使用辗转相除法获取用最大公约数求最小公倍数
 */
export const tcd = function(a, b) {
    return a / gcd(a, b) * b;
};
export const Spliter = class {
    constructor(strs = []) {
        const that = this;
        const { _, __ } = pri(that, { buffer: [], isComplete: false, root: {} });
        if (strs && strs.length > 0) {
            strs.forEach(v => {
                var ds = new Buffer.from(v).toJSON().data;
                var start = __.root;
                ds.forEach(v2 => {
                    if (start[v2]) {
                        start[v2].length++;
                    } else start[v2] = { length: 1 };
                    start = start[v2];
                });
                if (start.length > 1) throw new Error('分隔符之间不能存在包含或者重复关系');
                start.end = v;
            });
            __.now = __.root;
        } else throw new Error('构造函数必须输入字符值');
    }
    next(data) {
        const { _, __ } = pri(that);
        if (__.now[data]) {
            __.buffer.push(data);
            if (__.now[data].end) {
                __.isComplete = true;
                __.buffer = __.now[data].end;
            }
            __.now = __.now[data];
            return true;
        } else return false;
    }
    get isComplete() { return __.isComplete; }
    get rest() { return __.buffer; }
    reset() {
        const { _, __ } = pri(that);
        __.buffer = [];
        __.isComplete = false;
        __.now = __.root;
    }
};
export default { gcd, tcd, Spliter };
const pri = V.pris();